<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Distributed Compute - Узел</title>
  <style>
    :root {
      --bg: #1a1d23;
      --panel: #252830;
      --border: #3d424d;
      --text: #e6e8ec;
      --muted: #8b909a;
      --accent: #5c9ead;
      --success: #7cb342;
      --error: #e57373;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 12px 20px 24px;
      min-height: 100vh;
    }
    h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 16px;
      color: var(--accent);
    }
    .tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }
    .tabs::-webkit-scrollbar { height: 6px; }
    .tabs::-webkit-scrollbar-thumb { background: var(--border); border-radius: 6px; }
    .tabs button {
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 10px 16px;
      cursor: pointer;
      font-size: 0.95rem;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      flex: 0 0 auto;
      white-space: nowrap;
    }
    .tabs button:hover { color: var(--text); }
    .tabs button.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }
    .panel {
      display: none;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
    }
    .panel.active { display: block; }
    .overview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 14px;
    }
    .card .label { color: var(--muted); font-size: 0.85rem; margin-bottom: 4px; }
    .card .value { font-size: 1.5rem; font-weight: 600; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    button.primary {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 18px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
    }
    button.primary:hover { filter: brightness(1.1); }
    button.primary:disabled { opacity: 0.6; cursor: not-allowed; }
    input[type="text"], input[type="number"], input[type="password"] {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 6px;
      min-width: 200px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .table-responsive {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .table-responsive table { min-width: 620px; }
    th, td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
    }
    th { color: var(--muted); font-weight: 500; }
    tr:hover { background: rgba(255,255,255,0.03); }
    #table-contracts td {
      max-width: 300px;
      word-wrap: break-word;
    }
    #table-contracts td:first-child {
      min-width: 200px;
    }
    #table-contracts td:nth-child(3) {
      max-width: 400px;
      font-size: 0.9em;
      color: var(--muted);
    }
    #table-contracts td .progress-pct { font-weight: 600; }
    #table-contracts .btn-take-task { font-size: 0.85rem; padding: 6px 12px; }
    #table-contracts { min-width: 1180px; }
    #table-tasks { min-width: 680px; }
    #table-chain { min-width: 720px; }
    .saved-client-row { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-size: 0.9rem; }
    .saved-client-row > span { flex: 1 1 auto; min-width: 0; word-break: break-word; }
    .saved-client-row button { padding: 4px 10px; font-size: 0.85rem; }
    .mono { font-family: ui-monospace, monospace; font-size: 0.85em; }
    .hash { max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    .msg { margin-top: 12px; padding: 10px; border-radius: 6px; font-size: 0.9rem; }
    .msg.info { background: rgba(92, 158, 173, 0.2); color: var(--accent); }
    .msg.err { background: rgba(229, 115, 115, 0.15); color: var(--error); }
    .msg.ok { background: rgba(124, 179, 66, 0.15); color: var(--success); }
    .node-links { margin-bottom: 16px; font-size: 0.9rem; color: var(--muted); }
    .node-links a { color: var(--accent); margin-right: 12px; }
    .loading { color: var(--muted); }
    .muted { color: var(--muted); }
    .progress-bar {
      height: 8px; background: var(--bg); border-radius: 4px; overflow: hidden; margin-top: 8px; max-width: 300px;
    }
    .progress-bar div { height: 100%; background: var(--accent); transition: width 0.2s; }
    @media (max-width: 900px) {
      body { padding: 10px 12px 18px; }
      h1 { font-size: 1.08rem; margin-bottom: 12px; }
      .node-links { display: flex; flex-wrap: wrap; gap: 8px; }
      .node-links a { margin-right: 0; }
      .panel { padding: 14px; }
      .overview-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
      }
      .card .value { font-size: 1.2rem; }
      .row { align-items: stretch; }
      .row > label,
      .row > strong,
      .row > p,
      .row > code,
      .row > .msg { width: 100%; }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      select,
      button.primary {
        width: 100%;
        min-width: 0 !important;
      }
      #select-client { margin-left: 0 !important; }
      .saved-client-row {
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
      }
      .saved-client-row button { width: 100%; }
      .msg { word-break: break-word; }
      pre { font-size: 0.8rem; }
      #work-worker-cmd { width: 100%; }
      #work-worker-balance-result { margin-left: 0 !important; margin-top: 8px; }
    }
  </style>
</head>
<body>
  <h1>Distributed Compute - Узел оркестратора</h1>
  <div class="node-links">
    Узел: <span id="current-node">текущий</span>
    <a href="/dashboard">Обновить</a>
    <a href="/explorer">Explorer</a>
  </div>
  <div class="tabs">
    <button type="button" data-tab="overview" class="active">Обзор</button>
    <button type="button" data-tab="work">Работа</button>
    <button type="button" data-tab="contracts">Контракты</button>
    <button type="button" data-tab="provider">Мой Сектор</button>
    <button type="button" data-tab="tasks">Задачи</button>
    <button type="button" data-tab="chain">Блокчейн</button>
    <button type="button" data-tab="stats">Статистика</button>
    <button type="button" data-tab="profile">Профиль</button>
  </div>

  <div id="panel-overview" class="panel active">
    <div class="overview-grid">
      <div class="card"><div class="label">Состояние узла</div><div id="ov-status" class="value">-</div></div>
      <div class="card"><div class="label">Длина цепочки</div><div id="ov-chain" class="value">-</div></div>
      <div class="card"><div class="label">Вычислителей</div><div id="ov-clients" class="value">-</div></div>
      <div class="card"><div class="label">Транзакций в очереди</div><div id="ov-pending" class="value">-</div></div>
    </div>
    <div class="card" style="margin-bottom:20px;">
      <div class="label">Вычислители</div>
      <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Контракты выполняются распределённо: вычислители получают задания, выполняют работу и сдают результат. Награды начисляются на баланс того вычислителя, с чьим API-ключом получена задача и сдана работа. Добавьте вычислителей (вход/регистрация или API-ключ) - прогресс и баланс сохраняются для каждого.</p>
      <div class="row" style="align-items:center; margin-bottom:12px;">
        <label>Текущий вычислитель:</label>
        <select id="select-client" style="margin-left:8px; min-width:220px; background:var(--bg); border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:6px;">
          <option value="">- Ввести ключ вручную -</option>
        </select>
        <button type="button" class="primary" id="btn-sync-workers">Обновить данные</button>
      </div>
      <div id="saved-clients-list" class="card" style="margin-bottom:16px; max-height:200px; overflow:auto;"></div>
    <p class="label" style="margin-bottom:8px;">Добавить вычислителя</p>
    <p class="muted" style="font-size:0.85em; margin-bottom:8px;">Вход или регистрация создают вычислителя в списке; награды будут начисляться на его баланс. Либо добавьте уже имеющийся API-ключ.</p>
    <div id="auth-forms">
        <div class="row" style="margin-bottom:8px;">
          <input type="text" id="auth-login" placeholder="Логин" style="min-width:120px;">
          <input type="password" id="auth-password" placeholder="Пароль" style="min-width:120px;">
          <input type="text" id="auth-reg-nickname" placeholder="Никнейм (при регистрации)" style="min-width:140px;">
          <button type="button" class="primary" id="btn-auth-login">Войти</button>
          <button type="button" class="primary" id="btn-auth-register">Зарегистрироваться</button>
        </div>
        <div class="row">
          <span class="muted" style="margin-right:8px;">или вставить API-ключ:</span>
          <input type="text" id="input-api-key" placeholder="Вставьте api_key" style="min-width:180px;">
          <button type="button" class="primary" id="btn-add-client">Добавить</button>
        </div>
        <span id="auth-msg" class="msg" style="display:none;"></span>
      </div>
      <div id="auth-profile" style="display:none;">
        <p><strong>Вы вошли как</strong> <span id="profile-nickname">-</span> <span id="profile-login" class="muted" style="font-size:0.9em;"></span></p>
        <p>Fiat-кошелёк: <strong id="profile-balance">RUB: 0 · USD: 0 · EUR: 0</strong> · Сдано работ: <strong id="profile-submissions">0</strong></p>
        <p class="muted" style="font-size:0.85em; margin-top:8px;">Основные взаиморасчёты ведутся в валютах контракта (RUB/USD/EUR). Chain points отображаются в профиле как служебная метрика.</p>
        <button type="button" id="btn-auth-logout">Выйти</button>
      </div>
      <div class="row" style="margin-top:12px;">
        <button type="button" class="primary" id="btn-balance">Показать баланс текущего</button>
        <span id="balance-msg" class="msg" style="display:none;"></span>
      </div>
      <div class="row" style="margin-top:14px; align-items:center;">
        <a
          class="primary"
          href="/download/desktop-agent"
          style="text-decoration:none; display:inline-block; padding:14px 22px; border-radius:10px; font-size:1.05rem; font-weight:700; background:#2f7df6; color:#fff; box-shadow:0 8px 24px rgba(47,125,246,0.35);"
        >Скачать Desktop Agent</a>
        <span class="muted" style="font-size:0.9em;">Скачивается zip-архив (desktop_agent + shared): распакуйте и запустите <code>python desktop_agent_app.py</code> в папке <code>desktop_agent</code>. Режим по умолчанию: <code>adaptive</code>.</span>
      </div>
    </div>
  </div>

  <div id="panel-work" class="panel">
    <p class="label">Текущий вычислитель</p>
    <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Выберите вычислителя на вкладке «Обзор» или вставьте его API-ключ там. Награда за сданную работу начисляется на баланс этого вычислителя.</p>
    <div class="row" style="margin-bottom:12px;">
      <span class="muted" style="font-size:0.9em;">Используется API-ключ выбранного вычислителя из вкладки «Обзор». Для смены вычислителя вернитесь на вкладку «Обзор».</span>
    </div>
    <div class="row">
      <button type="button" class="primary" id="btn-get-task">Получить задачу</button>
      <span id="work-task-msg" class="msg" style="display:none;"></span>
    </div>
    <div id="work-task-spec" class="card" style="display:none; margin-bottom: 16px;">
      <div class="label">Текущая задача</div>
      <div class="mono" id="work-task-body"></div>
    </div>
      <div id="work-run-in-worker" class="card" style="display:none; margin-bottom: 16px;">
      <div class="label">Выполнить задачу в воркере</div>
      <p class="muted" style="font-size:0.85em; margin-bottom:8px;">Воркер запускается с API-ключом выбранного вычислителя (вкладка «Обзор») и <strong>только для контракта текущей задачи</strong> (см. блок «Текущая задача» выше). Награда начислится на этого вычислителя. Перед запуском нажмите «Использовать» для нужного вычислителя и при необходимости «Обновить данные».</p>
      <p class="muted" style="font-size:0.8em; margin-bottom:8px;">Если на баланс уже начислялись выплаты за другие контракты — вероятно, работал ещё один воркер (другой контейнер или запуск без выбора задачи). Остановите все контейнеры воркеров (<code>docker ps</code>, затем <code>docker stop &lt;id&gt;</code>), затем запустите воркер заново после получения нужной задачи.</p>
      <div class="row" style="align-items:center; gap:16px; margin-bottom:12px; flex-wrap:wrap;">
        <span class="muted" style="font-size:0.9em;">Режим воркера:</span>
        <label style="display:inline-flex; align-items:center; gap:6px; cursor:pointer;">
          <input type="radio" name="work-worker-mode" id="work-worker-mode-loop" value="loop" checked>
          <span>Брать следующую задачу автоматически (цикл до остановки)</span>
        </label>
        <label style="display:inline-flex; align-items:center; gap:6px; cursor:pointer;">
          <input type="radio" name="work-worker-mode" id="work-worker-mode-once" value="once">
          <span>Выполнить одну задачу и остановиться</span>
        </label>
      </div>
      <div class="row" style="align-items:center; gap:12px; margin-bottom:12px;">
        <button type="button" class="primary" id="btn-start-worker">Запустить воркер автоматически</button>
        <span id="work-run-worker-msg" class="msg" style="display:none;"></span>
      </div>
      <div id="work-worker-status-hint" style="display:none; margin-top:8px;">
        <button type="button" class="primary" id="btn-check-balance-after-worker">Проверить баланс</button>
        <span id="work-worker-balance-result" class="msg" style="display:none; margin-left:8px;"></span>
        <p style="font-size:0.85em; color:var(--muted); margin:8px 0 0;">Через 10–60 сек воркер сдаст задачу. Вкладка «Задачи» - история сданных работ; «Профиль» - fiat-кошелёк и вывод.</p>
      </div>
      <p style="font-size:0.9em; color:var(--muted); margin:0 0 8px;">Или вручную в каталоге проекта:</p>
      <div class="row" style="align-items:center; gap:8px;">
        <code id="work-worker-cmd" class="mono" style="flex:1; background:var(--bg); padding:8px 12px; border-radius:6px; font-size:0.85rem; word-break:break-all;"></code>
        <button type="button" class="primary" id="btn-copy-worker-cmd">Копировать</button>
      </div>
      <p style="font-size:0.8em; color:var(--muted); margin:8px 0 0;">В Windows (CMD): <code>set CONTRACT_ID=<span id="work-worker-cid"></span><span id="work-worker-win-once"></span> &amp;&amp; docker-compose run --rm client_worker_1</code></p>
    </div>
    <div class="row">
      <button type="button" class="primary" id="btn-run-work" disabled>Выполнить в браузере</button>
      <span id="work-progress" class="msg info" style="display:none;"></span>
      <p style="font-size:0.85em; color:var(--muted); margin-top:8px;">
        <strong>Примечание:</strong> Для астрофизических задач в браузере выполняется упрощённая версия (до 1000 единиц работы для скорости).
        Для получения награды требуется выполнить полный объём работы - используйте воркеры для полных вычислений.
        Простые пользовательские контракты (simple_pow) можно выполнять полностью в браузере.
      </p>
    </div>
    <div id="work-result" class="msg" style="display:none;"></div>
  </div>

  <div id="panel-contracts" class="panel">
    <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Контракты поставщиков, доступные исполнителям. Вычислители берут задачу по контракту, выполняют требуемый объём работы и сдают результат. «Выполнено %» - доля от целевого объёма контракта; «Осталось» - сколько единиц работы ещё не выполнено; «Активных вычислителей» - кто недавно запрашивал задачу по этому контракту.</p>
    <p class="loading" id="contracts-load">Загрузка…</p>
    <div class="table-responsive">
      <table id="table-contracts" style="display:none;">
        <thead><tr><th>Название</th><th>Категория</th><th>Описание</th><th>Ед. на сдачу</th><th>Выполнено %</th><th>Активных вычислителей</th><th>Осталось (ед. работы)</th><th>Награда за сдачу</th><th>Действие</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="panel-provider" class="panel">
    <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Порядок работы: 1) создать сектор, 2) выбрать сектор, 3) создать и просматривать контракты внутри выбранного сектора. На этой вкладке доступны только ваши секторы и ваши контракты.</p>
    <p id="provider-auth-required" class="msg info" style="display:none;">Выберите вычислителя (API-ключ) на вкладке «Обзор». Его аккаунт будет использован как владелец ваших секторов.</p>
    <div class="card" style="margin-bottom:16px;">
      <div class="label">1) Выбор сектора</div>
      <div class="row">
        <label for="provider-sector-select" class="muted">Текущий сектор:</label>
        <select id="provider-sector-select" style="min-width:220px;"></select>
        <button type="button" class="primary" id="btn-provider-sectors-refresh">Обновить секторы</button>
      </div>
      <div class="row">
        <span id="provider-sector-msg" class="msg" style="display:none;"></span>
      </div>
    </div>
    <div class="card" style="margin-bottom:16px;">
      <div class="label">2) Регистрация нового сектора</div>
      <div class="row">
        <input type="text" id="provider-sector-name" placeholder="Название сектора" style="min-width:220px;">
        <input type="text" id="provider-sector-org" placeholder="Организация/институт/частное лицо" style="min-width:260px;">
        <input type="text" id="provider-sector-domain" placeholder="Целевая область вычислений" style="min-width:220px;">
      </div>
      <div class="row">
        <input type="text" id="provider-sector-description" placeholder="Описание сектора (опционально)" style="min-width:460px;">
      </div>
      <div class="row">
        <button type="button" class="primary" id="btn-provider-sector-create">Создать сектор</button>
      </div>
    </div>
    <div id="provider-sector-info-card" class="card" style="margin-bottom:16px; display:none;">
      <div class="label">3) Выбранный сектор: сводка</div>
      <div class="overview-grid" style="margin-top:12px;">
        <div class="card"><div class="label">Название</div><div id="provider-sector-info-name" class="value">-</div></div>
        <div class="card"><div class="label">Организация</div><div id="provider-sector-info-org" class="value">-</div></div>
        <div class="card"><div class="label">Область</div><div id="provider-sector-info-domain" class="value">-</div></div>
        <div class="card"><div class="label">Контрактов</div><div id="provider-sector-info-contracts" class="value">0</div></div>
        <div class="card"><div class="label">Активных</div><div id="provider-sector-info-active" class="value">0</div></div>
        <div class="card"><div class="label">Бюджет доступно</div><div id="provider-sector-info-budget" class="value">0</div></div>
      </div>
    </div>
    <div id="provider-contract-create-card" class="card" style="margin-bottom:16px; display:none;">
      <div class="label">4) Создать контракт в выбранном секторе</div>
      <div class="row">
        <input type="text" id="provider-task-name" placeholder="Название задачи" style="min-width:200px;">
        <input type="text" id="provider-task-category" placeholder="Категория (опционально)" style="min-width:180px;">
        <select id="provider-computation-type" style="min-width:180px;">
          <option value="modeling_simulations">Моделирование и симуляции</option>
          <option value="biomedicine">Биомедицина</option>
          <option value="artificial_intelligence">Искусственный интеллект</option>
          <option value="data_analysis">Анализ данных</option>
        </select>
      </div>
      <div class="row">
        <small style="color:var(--muted);">
          В этом списке выбирается типология задачи для интерфейса. Внутренний вычислительный профиль подставляется автоматически для совместимости.
        </small>
      </div>
      <div class="row">
        <input type="number" id="provider-work-units" min="1" step="1" placeholder="Ед. на сдачу" style="min-width:140px;">
        <input type="number" id="provider-reward" min="1" step="1" placeholder="Награда за сдачу" style="min-width:150px;">
        <select id="provider-budget-currency" style="min-width:120px;">
          <option value="RUB">RUB</option>
          <option value="USD">USD</option>
          <option value="EUR">EUR</option>
        </select>
        <input type="number" id="provider-target" min="1" step="1" placeholder="Целевой объём" style="min-width:150px;">
        <input type="number" id="provider-difficulty" min="1" step="1" placeholder="Difficulty" style="min-width:120px;">
        <input type="number" id="provider-initial-budget" min="0" step="1" placeholder="Начальный бюджет" style="min-width:150px;">
      </div>
      <div class="row">
        <input type="text" id="provider-task-description" placeholder="Описание задачи" style="min-width:460px;">
      </div>
      <div class="row" style="align-items:center;">
        <label style="display:inline-flex; align-items:center; gap:6px;">
          <input type="checkbox" id="provider-activate-now" checked>
          <span>Сразу активировать</span>
        </label>
      </div>
      <div class="row">
        <button type="button" class="primary" id="btn-provider-create">Создать контракт</button>
        <span id="provider-create-msg" class="msg" style="display:none;"></span>
      </div>
    </div>
      <p id="provider-sector-required-msg" class="msg info" style="display:none; margin-bottom:16px;">Сначала создайте и выберите сектор из своих. После этого станет доступно создание контрактов внутри него.</p>
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div class="label">5) Контракты выбранного сектора</div>
        <button type="button" class="primary" id="btn-provider-refresh">Обновить</button>
      </div>
      <p class="loading" id="provider-load">Загрузка…</p>
      <p id="provider-empty" class="muted" style="display:none;">Контрактов пока нет.</p>
      <div class="table-responsive">
        <table id="table-provider-contracts" style="display:none;">
          <thead><tr><th>ID</th><th>Сектор</th><th>Название</th><th>Статус</th><th>Награда</th><th>Прогресс</th><th>Бюджет (доступно)</th><th>Управление</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="panel-tasks" class="panel">
    <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Сданные работы (work_receipt) из блокчейна: вычислитель, контракт и количество единиц работы. Показаны последние 100 записей из последних 100 блоков (если сдачи по нужному контракту нет — она могла быть в более старом блоке).</p>
    <p class="loading" id="tasks-load">Загрузка…</p>
    <p id="tasks-empty" style="display:none; color: var(--muted);">Нет сданных работ в последних блоках.</p>
    <div class="table-responsive">
      <table id="table-tasks" style="display:none;">
        <thead><tr><th>Блок</th><th>Вычислитель</th><th>Контракт</th><th>Ед. работы</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="panel-chain" class="panel">
    <p class="muted" style="font-size:0.9em; margin-bottom:12px;">
      Краткая сводка chain. Детальный просмотр блоков и адресов — в Explorer.
    </p>
    <div class="row" style="margin-bottom:12px; align-items:center;">
      <a
        class="primary"
        href="/explorer"
        target="_blank"
        rel="noopener"
        style="text-decoration:none; display:inline-block; padding:10px 16px; border-radius:8px;"
      >Открыть Explorer</a>
    </div>
    <p class="loading" id="chain-load">Загрузка…</p>
    <div class="overview-grid">
      <div class="card"><div class="label">Последний блок</div><div id="chain-last-index" class="value">-</div></div>
      <div class="card"><div class="label">Транзакций в последнем блоке</div><div id="chain-last-tx-count" class="value">-</div></div>
      <div class="card"><div class="label">Обновлён</div><div id="chain-last-ts" class="value">-</div></div>
    </div>
  </div>

  <div id="panel-stats" class="panel">
    <div class="overview-grid" style="margin-bottom: 20px;">
      <div class="card"><div class="label">Длина цепочки</div><div id="st-chain" class="value">-</div></div>
      <div class="card"><div class="label">Вычислителей (зарегистрировано)</div><div id="st-clients" class="value">-</div></div>
      <div class="card"><div class="label">Транзакций в очереди (pending)</div><div id="st-pending" class="value">-</div></div>
    </div>
    <p class="label">Запросы по путям</p>
    <pre id="st-requests" class="mono" style="background:var(--bg); padding:12px; border-radius:6px; overflow:auto; max-height:200px;"></pre>
    <p class="label" style="margin-top:12px;">Ошибки</p>
    <pre id="st-errors" class="mono" style="background:var(--bg); padding:12px; border-radius:6px; overflow:auto;"></pre>
  </div>

  <div id="panel-profile" class="panel">
    <p id="profile-login-required" class="msg info" style="display:none;">Войдите или выберите вычислителя с API-ключом на вкладке «Обзор», чтобы видеть профиль и вывод средств.</p>
    <div id="profile-content" style="display:none;">
      <div class="card" style="margin-bottom:20px;">
        <div class="label">Данные профиля</div>
        <div class="overview-grid" style="margin-top:12px;">
          <div class="card"><div class="label">Никнейм</div><div id="profile-nickname-full" class="value">-</div></div>
          <div class="card"><div class="label">Логин</div><div id="profile-login-full" class="value">-</div></div>
          <div class="card"><div class="label">ID вычислителя</div><div id="profile-client-id" class="value mono" style="font-size:0.9rem; word-break:break-all;">-</div></div>
          <div class="card"><div class="label">Fiat-кошелёк</div><div id="profile-fiat-wallet" class="value" style="font-size:0.9rem;">-</div></div>
          <div class="card"><div class="label">Chain points (служебно)</div><div id="profile-balance-full" class="value">-</div></div>
          <div class="card"><div class="label">Сдано работ</div><div id="profile-submissions-full" class="value">-</div></div>
        </div>
      </div>
      <div id="profile-worker-progress-card" class="card" style="display:none; margin-bottom:20px;">
        <div class="label">Активные задачи и прогресс воркера</div>
        <p class="muted" style="font-size:0.9em; margin-bottom:8px;">Текущая задача, которую выполняет воркер под этим аккаунтом (если запущен), и прогресс вычисления.</p>
        <p id="profile-worker-progress-text" class="muted" style="margin:8px 0 4px 0;">Вычисление…</p>
        <progress id="profile-worker-progress-bar" value="0" max="100" style="width:100%; height:12px; border-radius:6px;"></progress>
        <p id="profile-worker-no-task" class="muted" style="display:none; margin-top:8px;">Нет активной задачи. Запустите воркер на вкладке «Работа».</p>
      </div>
      <div class="card" style="margin-bottom:20px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="label">Мои задания (desktop-agent)</div>
          <button type="button" class="primary" id="btn-profile-jobs-refresh">Обновить</button>
        </div>
        <p id="profile-jobs-empty" class="muted" style="display:none;">Заданий пока нет.</p>
        <div class="table-responsive">
          <table id="table-profile-jobs" style="display:none;">
            <thead><tr><th>Job</th><th>Контракт</th><th>Статус</th><th>Профиль</th><th>Переназначений</th><th>Обновлено</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="card" style="margin-bottom:20px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="label">Мои устройства</div>
          <button type="button" class="primary" id="btn-profile-devices-refresh">Обновить</button>
        </div>
        <p id="profile-devices-empty" class="muted" style="display:none;">Устройств пока нет.</p>
        <div class="table-responsive">
          <table id="table-profile-devices" style="display:none;">
            <thead><tr><th>ID</th><th>Имя</th><th>Версия</th><th>Статус</th><th>Причина</th><th>Последняя синхронизация</th><th>Управление</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="card" style="margin-bottom:20px;">
        <div class="label">Fiat-операции и вывод на карту</div>
        <p class="muted" style="font-size:0.9em; margin-bottom:12px;">Реальная модель без криптовалют: доход учитывается в валюте контракта (RUB/USD/EUR), доступна конвертация и заявка на вывод на банковскую карту.</p>
        <div class="row" style="align-items:center; gap:12px; margin-bottom:12px;">
          <label for="profile-topup-currency">Пополнение:</label>
          <select id="profile-topup-currency" style="min-width:110px;">
            <option value="RUB">RUB</option>
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
          </select>
          <input type="number" id="profile-topup-amount" min="1" step="1" placeholder="Сумма" style="min-width:120px;">
          <button type="button" class="primary" id="btn-profile-topup">Пополнить кошелёк</button>
        </div>
        <div class="row" style="align-items:center; gap:12px; margin-bottom:12px;">
          <label for="profile-convert-from">Конвертация:</label>
          <select id="profile-convert-from" style="min-width:90px;">
            <option value="RUB">RUB</option>
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
          </select>
          <span>→</span>
          <select id="profile-convert-to" style="min-width:90px;">
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
            <option value="RUB">RUB</option>
          </select>
          <input type="number" id="profile-convert-amount" min="1" step="1" placeholder="Сумма" style="min-width:120px;">
          <button type="button" class="primary" id="btn-profile-convert">Конвертировать</button>
        </div>
        <div class="row" style="align-items:center; gap:12px; margin-bottom:12px;">
          <label for="profile-withdraw-currency">Вывод:</label>
          <select id="profile-withdraw-currency" style="min-width:90px;">
            <option value="RUB">RUB</option>
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
          </select>
          <input type="number" id="profile-withdraw-amount" min="1" step="1" placeholder="Сумма" style="min-width:120px;">
        </div>
        <div class="row" style="align-items:center; gap:12px; margin-bottom:12px;">
          <label for="profile-withdraw-card">Номер карты:</label>
          <input type="text" id="profile-withdraw-card" placeholder="0000 0000 0000 0000" maxlength="19" style="min-width:200px;" pattern="[0-9\s]{12,19}" inputmode="numeric">
        </div>
        <div class="row">
          <button type="button" class="primary" id="btn-profile-withdraw">Вывести на карту</button>
          <span id="profile-withdraw-msg" class="msg" style="display:none; margin-left:12px;"></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Базовый URL текущего узла для всех API-запросов
    const base = window.location.origin;
    document.getElementById('current-node').textContent = base;

    // Ключи для localStorage: сохранение вычислителей и текущей задачи
    const STORAGE_KEY_CLIENTS = 'dc_clients';
    const STORAGE_KEY_CURRENT_TASK = 'dc_current_task';
    const STORAGE_KEY_TASK_CLIENT_ID = 'dc_task_client_id';

    /**
     * Переключение между вкладками интерфейса.
     * При переключении загружаются соответствующие данные и запускаются/останавливаются периодические обновления.
     * @param {string} id - Идентификатор вкладки (overview, work, contracts, provider, tasks, chain, stats, profile)
     */
    function showPanel(id) {
      // Скрываем все панели и убираем активное состояние у всех кнопок
      document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
      document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
      
      // Активируем выбранную панель и кнопку
      const panel = document.getElementById('panel-' + id);
      const btn = document.querySelector('.tabs button[data-tab="' + id + '"]');
      if (panel) panel.classList.add('active');
      if (btn) btn.classList.add('active');
      
      // Загружаем данные в зависимости от выбранной вкладки
      if (id === 'overview') {
        loadOverview();
        startOverviewAutoRefresh(); // Запускаем автообновление для вкладки "Обзор"
      } else {
        stopOverviewAutoRefresh(); // Останавливаем автообновление при переключении на другую вкладку
      }
      
      if (id === 'profile') { 
        startWorkerProgressPolling(); 
        loadProfile();
      } else { 
        stopWorkerProgressPolling(); 
      }
      if (id === 'contracts') loadContracts();
      if (id === 'provider') loadProviderPanel();
      if (id === 'tasks') loadTasks();
      if (id === 'chain') loadChain();
      if (id === 'stats') loadStats();
    }
    
    // Обработчики кликов по вкладкам
    document.querySelectorAll('.tabs button').forEach(b => {
      b.addEventListener('click', () => showPanel(b.dataset.tab));
    });

    /**
     * Универсальная функция для выполнения GET-запросов к API.
     * Выбрасывает ошибку при неверном статусе ответа.
     * @param {string} path - Путь API (например, '/metrics', '/chain')
     * @returns {Promise<Object>} JSON-ответ от сервера
     */
    async function api(path) {
      const r = await fetch(base + path);
      if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
      return r.json();
    }

    /**
     * Загрузка данных для вкладки "Обзор": состояние узла и метрики.
     * Обновляет карточки с информацией о состоянии узла, длине цепочки, количестве вычислителей и pending транзакциях.
     */
    function loadOverview() {
      Promise.all([fetch(base + '/health').then(r => r.json()), api('/metrics')])
        .then(([health, m]) => {
          document.getElementById('ov-status').textContent = health.status === 'ok' ? 'OK' : health.status || '-';
          document.getElementById('ov-chain').textContent = m.chain_length ?? '-';
          document.getElementById('ov-clients').textContent = m.clients_count ?? '-';
          document.getElementById('ov-pending').textContent = m.pending_transactions ?? '-';
        })
        .catch(() => {
          document.getElementById('ov-status').textContent = 'Ошибка';
          document.getElementById('ov-chain').textContent = '-';
          document.getElementById('ov-clients').textContent = '-';
          document.getElementById('ov-pending').textContent = '-';
        });
    }

    // Автообновление данных на вкладке "Обзор" каждые 30 секунд
    let overviewAutoRefreshIntervalId = null;
    function startOverviewAutoRefresh() {
      stopOverviewAutoRefresh();
      loadOverview(); // Загружаем сразу при открытии вкладки
      overviewAutoRefreshIntervalId = setInterval(loadOverview, 30000); // Обновляем каждые 30 секунд
    }
    function stopOverviewAutoRefresh() {
      if (overviewAutoRefreshIntervalId) {
        clearInterval(overviewAutoRefreshIntervalId);
        overviewAutoRefreshIntervalId = null;
      }
    }

    /**
     * Текущая задача, полученная через /get_task.
     * Сохраняется в localStorage для восстановления при перезагрузке страницы.
     */
    let currentTask = null;
    
    /**
     * ID вычислителя, для которого сейчас отображается задача на вкладке «Работа».
     * При смене аккаунта сбрасываем панель, чтобы избежать путаницы с задачами разных вычислителей.
     */
    let workPanelAccountId = null;

    /**
     * Получение списка сохранённых вычислителей из localStorage.
     * Каждый вычислитель содержит: id, label, apiKey, balance, submissions_count, client_id.
     * @returns {Array<Object>} Массив объектов вычислителей
     */
    function getSavedClients() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_CLIENTS);
        return raw ? JSON.parse(raw) : [];
      } catch (e) { return []; }
    }
    
    /**
     * Сохранение списка вычислителей в localStorage.
     * @param {Array<Object>} list - Массив объектов вычислителей для сохранения
     */
    function setSavedClients(list) {
      localStorage.setItem(STORAGE_KEY_CLIENTS, JSON.stringify(list));
    }
    
    /**
     * Сохранение текущей задачи в localStorage для восстановления при перезагрузке страницы.
     * Сохраняем также ID вычислителя, чтобы проверить при восстановлении, что задача всё ещё актуальна.
     */
    function saveCurrentTask() {
      if (currentTask && workPanelAccountId) {
        localStorage.setItem(STORAGE_KEY_CURRENT_TASK, JSON.stringify(currentTask));
        localStorage.setItem(STORAGE_KEY_TASK_CLIENT_ID, workPanelAccountId);
      } else {
        localStorage.removeItem(STORAGE_KEY_CURRENT_TASK);
        localStorage.removeItem(STORAGE_KEY_TASK_CLIENT_ID);
      }
    }
    
    /**
     * Восстановление текущей задачи из localStorage при загрузке страницы.
     * Проверяем, что задача соответствует текущему вычислителю, иначе не восстанавливаем.
     */
    function restoreCurrentTask() {
      try {
        const savedTask = localStorage.getItem(STORAGE_KEY_CURRENT_TASK);
        const savedClientId = localStorage.getItem(STORAGE_KEY_TASK_CLIENT_ID);
        if (savedTask && savedClientId) {
          const task = JSON.parse(savedTask);
          const currentClientId = getSelectedClientId();
          // Восстанавливаем задачу только если вычислитель не изменился
          if (currentClientId === savedClientId) {
            currentTask = task;
            workPanelAccountId = savedClientId;
            setCurrentTask(task);
          } else {
            // Если вычислитель изменился, очищаем сохранённую задачу
            localStorage.removeItem(STORAGE_KEY_CURRENT_TASK);
            localStorage.removeItem(STORAGE_KEY_TASK_CLIENT_ID);
          }
        }
      } catch (e) {
        // При ошибке парсинга просто игнорируем сохранённую задачу
        localStorage.removeItem(STORAGE_KEY_CURRENT_TASK);
        localStorage.removeItem(STORAGE_KEY_TASK_CLIENT_ID);
      }
    }
    /**
     * Обновление выпадающего списка вычислителей в интерфейсе.
     * Отображает баланс и количество сданных работ для каждого вычислителя.
     */
    function refreshClientSelect() {
      const list = getSavedClients();
      const sel = document.getElementById('select-client');
      const cur = sel.value;
      sel.innerHTML = '<option value="">- Ввести ключ вручную -</option>';
      list.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.id;
        const walletText = formatWalletBalances(c.fiat_wallet || {});
        const sub = c.submissions_count != null ? c.submissions_count : '-';
        opt.textContent = (c.label || 'Вычислитель') + ' · кошелёк: ' + walletText + ' · сдано: ' + sub;
        sel.appendChild(opt);
      });
      // Восстанавливаем выбранное значение, если оно всё ещё существует в списке
      if (cur && list.some(c => c.id === cur)) sel.value = cur;
    }
    
    /**
     * Синхронизация данных вычислителя с сервером через API /me.
     * Обновляет баланс и количество сданных работ из блокчейна.
     * @param {Object} c - Объект вычислителя с apiKey
     * @returns {Promise<Object>} Обновлённый объект вычислителя с актуальными данными
     */
    async function syncWorkerData(c) {
      if (!c.apiKey) return c;
      try {
        const r = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + c.apiKey } });
        if (!r.ok) return c;
        const d = await r.json();
        return {
          ...c,
          balance: d.balance ?? 0,
          fiat_wallet: d.fiat_wallet || c.fiat_wallet || {},
          submissions_count: d.submissions_count ?? 0,
          client_id: d.client_id || c.client_id,
        };
      } catch (e) { return c; }
    }
    
    /**
     * Проверка валидности API-ключа через запрос к /me.
     * Используется при вводе ключа для немедленной валидации.
     * @param {string} apiKey - API-ключ для проверки
     * @returns {Promise<{valid: boolean, error?: string, data?: Object}>} Результат проверки
     */
    async function validateApiKey(apiKey) {
      if (!apiKey || !apiKey.trim()) {
        return { valid: false, error: 'API-ключ не может быть пустым' };
      }
      try {
        const r = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + apiKey.trim() } });
        if (!r.ok) {
          const errorData = await r.json().catch(() => ({}));
          if (r.status === 401) {
            return { valid: false, error: 'Неверный API-ключ' };
          }
          return { valid: false, error: errorData.error || 'Ошибка проверки ключа' };
        }
        const data = await r.json();
        return { valid: true, data: data };
      } catch (e) {
        return { valid: false, error: 'Ошибка подключения к серверу: ' + e.message };
      }
    }
    document.getElementById('btn-sync-workers').onclick = async function() {
      const list = getSavedClients();
      if (!list.length) return;
      this.disabled = true;
      for (let i = 0; i < list.length; i++) {
        list[i] = await syncWorkerData(list[i]);
      }
      setSavedClients(list);
      refreshClientSelect();
      refreshSavedClientsList();
      this.disabled = false;
    };
    function refreshSavedClientsList() {
      const list = getSavedClients();
      const container = document.getElementById('saved-clients-list');
      container.innerHTML = '';
      if (!list.length) { container.innerHTML = '<span class="muted">Нет вычислителей. Войдите, зарегистрируйтесь или добавьте по API-ключу.</span>'; return; }
      list.forEach(c => {
        const row = document.createElement('div');
        row.className = 'saved-client-row';
        const walletText = formatWalletBalances(c.fiat_wallet || {});
        const sub = c.submissions_count != null ? c.submissions_count : '-';
        row.innerHTML = '<span><strong>' + (c.label || 'Вычислитель') + '</strong> - кошелёк: ' + walletText + ', сдано работ: ' + sub + '</span>' +
          '<button type="button" class="primary" data-use="' + c.id + '">Использовать</button>' +
          '<button type="button" class="primary" data-sync-one="' + c.id + '">Обновить</button>' +
          '<button type="button" data-remove="' + c.id + '">Удалить</button>';
        row.querySelector('[data-use]').onclick = () => {
          document.getElementById('input-api-key').value = c.apiKey || '';
          document.getElementById('select-client').value = c.id;
          if (getSelectedClientId() !== workPanelAccountId) clearWorkPanelForNewAccount();
          workPanelAccountId = getSelectedClientId();
        };
        row.querySelector('[data-sync-one]').onclick = async () => {
          const updated = await syncWorkerData(c);
          const newList = list.map(x => x.id === c.id ? updated : x);
          setSavedClients(newList);
          refreshClientSelect();
          refreshSavedClientsList();
        };
        row.querySelector('[data-remove]').onclick = () => {
          if (!confirm('Удалить вычислителя "' + (c.label || 'Вычислитель') + '"? Это действие нельзя отменить.')) {
            return;
          }
          setSavedClients(list.filter(x => x.id !== c.id));
          refreshClientSelect();
          refreshSavedClientsList();
        };
        container.appendChild(row);
      });
    }
    document.getElementById('select-client').onchange = function() {
      const id = this.value;
      const list = getSavedClients();
      const c = list.find(x => x.id === id);
      if (c && c.apiKey) {
        document.getElementById('input-api-key').value = c.apiKey;
      }
      if (getSelectedClientId() !== workPanelAccountId) clearWorkPanelForNewAccount();
      workPanelAccountId = getSelectedClientId();
      if (document.getElementById('panel-contracts').classList.contains('active')) loadContracts();
      if (document.getElementById('panel-provider').classList.contains('active')) loadProviderPanel();
    };
    /**
     * Обработчик добавления вычислителя по API-ключу.
     * Проверяет валидность ключа перед добавлением и синхронизирует данные с сервером.
     */
    document.getElementById('btn-add-client').onclick = async function() {
      const key = document.getElementById('input-api-key').value.trim();
      const msgEl = document.getElementById('auth-msg');
      msgEl.style.display = 'none';
      
      if (!key) { 
        msgEl.className = 'msg err'; 
        msgEl.textContent = 'Введите API-ключ.'; 
        msgEl.style.display = 'block'; 
        return; 
      }
      
      // Проверяем валидность API-ключа перед добавлением
      this.disabled = true;
      this.textContent = 'Проверка...';
      const validation = await validateApiKey(key);
      
      if (!validation.valid) {
        msgEl.className = 'msg err';
        msgEl.textContent = '❌ ' + validation.error;
        msgEl.style.display = 'block';
        this.disabled = false;
        this.textContent = 'Добавить';
        return;
      }
      
      // Проверяем, не добавлен ли уже этот ключ
      const list = getSavedClients();
      const existing = list.find(c => c.apiKey === key);
      if (existing) {
        msgEl.className = 'msg info';
        msgEl.textContent = 'Этот вычислитель уже добавлен.';
        msgEl.style.display = 'block';
        document.getElementById('select-client').value = existing.id;
        this.disabled = false;
        this.textContent = 'Добавить';
        return;
      }
      
      // Добавляем вычислителя с данными из сервера
      const id = 'c' + Date.now();
      const label = validation.data?.nickname || validation.data?.login || 'Вычислитель ' + (list.length + 1);
      const newClient = { 
        id, 
        label: label,
        apiKey: key,
        balance: validation.data?.balance ?? 0,
        submissions_count: validation.data?.submissions_count ?? 0,
        client_id: validation.data?.client_id
      };
      list.push(newClient);
      setSavedClients(list);
      refreshClientSelect();
      refreshSavedClientsList();
      document.getElementById('select-client').value = id;
      msgEl.className = 'msg ok';
      msgEl.textContent = '✅ Вычислитель добавлен: ' + label;
      msgEl.style.display = 'block';
      this.disabled = false;
      this.textContent = 'Добавить';
      if (document.getElementById('panel-provider').classList.contains('active')) loadProviderPanel();
    };
    refreshClientSelect();
    refreshSavedClientsList();
    
    // Восстанавливаем сохранённую задачу после загрузки списка вычислителей
    // Используем setTimeout, чтобы гарантировать, что список вычислителей уже загружен
    setTimeout(() => {
      restoreCurrentTask();
    }, 100);

    const AUTH_API_KEY = 'dc_auth_api_key';
    const AUTH_NICKNAME = 'dc_auth_nickname';
    const AUTH_LOGIN = 'dc_auth_login';
    function showAuthProfile() {
      document.getElementById('auth-forms').style.display = 'none';
      document.getElementById('auth-profile').style.display = 'block';
    }
    function showAuthForms() {
      document.getElementById('auth-forms').style.display = 'block';
      document.getElementById('auth-profile').style.display = 'none';
      document.getElementById('auth-msg').style.display = 'none';
    }
    async function refreshProfileFromMe() {
      const key = localStorage.getItem(AUTH_API_KEY);
      if (!key) return;
      try {
        const r = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + key } });
        if (!r.ok) return;
        const d = await r.json();
        document.getElementById('profile-nickname').textContent = d.nickname || d.login || d.client_id?.slice(0, 8) + '…';
        document.getElementById('profile-login').textContent = d.login ? '(' + d.login + ')' : '';
        document.getElementById('profile-balance').textContent = formatWalletBalances(d.fiat_wallet || {});
        document.getElementById('profile-submissions').textContent = d.submissions_count ?? 0;
      } catch (e) {}
    }
    async function applyAuthSession(apiKey, nickname, login) {
      localStorage.setItem(AUTH_API_KEY, apiKey);
      if (nickname) localStorage.setItem(AUTH_NICKNAME, nickname);
      if (login) localStorage.setItem(AUTH_LOGIN, login);
      document.getElementById('input-api-key').value = apiKey;
      const list = getSavedClients();
      const existing = list.find(c => c.apiKey === apiKey);
      if (!existing) {
        const newItem = { id: 'auth-' + Date.now(), label: nickname || login || 'Вычислитель', apiKey: apiKey };
        const withStats = await syncWorkerData(newItem);
        list.push(withStats);
        setSavedClients(list);
        refreshClientSelect();
        refreshSavedClientsList();
      }
      showAuthProfile();
      refreshProfileFromMe();
      if (document.getElementById('panel-provider').classList.contains('active')) loadProviderPanel();
    }
    document.getElementById('btn-auth-login').onclick = async function() {
      const login = document.getElementById('auth-login').value.trim();
      const password = document.getElementById('auth-password').value;
      const msg = document.getElementById('auth-msg');
      msg.style.display = 'none';
      if (!login || !password) { msg.className = 'msg err'; msg.textContent = 'Введите логин и пароль.'; msg.style.display = 'block'; return; }
      try {
        const r = await fetch(base + '/auth/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ login: login, password: password }) });
        const d = await r.json();
        if (!r.ok) { msg.className = 'msg err'; msg.textContent = d.error || r.status; msg.style.display = 'block'; return; }
        await applyAuthSession(d.api_key, d.nickname, d.login);
      } catch (e) { msg.className = 'msg err'; msg.textContent = 'Ошибка: ' + e.message; msg.style.display = 'block'; }
    };
    document.getElementById('btn-auth-register').onclick = async function() {
      const login = document.getElementById('auth-login').value.trim();
      const password = document.getElementById('auth-password').value;
      const nickname = document.getElementById('auth-reg-nickname').value.trim();
      const msg = document.getElementById('auth-msg');
      msg.style.display = 'none';
      if (!login || !password) { msg.className = 'msg err'; msg.textContent = 'Введите логин и пароль (пароль не менее 6 символов).'; msg.style.display = 'block'; return; }
      try {
        const r = await fetch(base + '/auth/register', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ login: login, password: password, nickname: nickname || login }) });
        const d = await r.json();
        if (!r.ok) { msg.className = 'msg err'; msg.textContent = d.error || r.status; msg.style.display = 'block'; return; }
        await applyAuthSession(d.api_key, d.nickname, d.login);
      } catch (e) { msg.className = 'msg err'; msg.textContent = 'Ошибка: ' + e.message; msg.style.display = 'block'; }
    };
    document.getElementById('btn-auth-logout').onclick = function() {
      localStorage.removeItem(AUTH_API_KEY);
      localStorage.removeItem(AUTH_NICKNAME);
      localStorage.removeItem(AUTH_LOGIN);
      document.getElementById('input-api-key').value = '';
      showAuthForms();
      if (document.getElementById('panel-contracts').classList.contains('active')) loadContracts();
      if (document.getElementById('panel-provider').classList.contains('active')) loadProviderPanel();
    };
    if (localStorage.getItem(AUTH_API_KEY)) {
      const key = localStorage.getItem(AUTH_API_KEY);
      document.getElementById('input-api-key').value = key;
      showAuthProfile();
      refreshProfileFromMe();
    } else {
      showAuthForms();
    }

    async function sha256Hex(str) {
      const buf = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest('SHA-256', buf);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function runPoW(clientId, contractId, workUnitsRequired, difficulty, onProgress) {
      const targetPrefix = '0'.repeat(difficulty);
      let workUnitsDone = 0;
      let resultData = null, solutionNonce = null;
      while (workUnitsDone < workUnitsRequired || !solutionNonce) {
        workUnitsDone += 1;
        const nonce = String(workUnitsDone);
        const text = clientId + '-' + contractId + '-' + nonce;
        const hashHex = await sha256Hex(text);
        if (hashHex.startsWith(targetPrefix)) {
          resultData = hashHex;
          solutionNonce = nonce;
        }
        if (workUnitsDone % 50 === 0) onProgress(workUnitsDone);
      }
      return { work_units_done: workUnitsDone, result_data: resultData, nonce: solutionNonce };
    }

    // Упрощённые версии астрофизических вычислений для браузера (для демонстрации)
    async function runAstrophysicsComputation(clientId, contractId, workUnitsRequired, computationType, onProgress) {
      // Для браузера используем упрощённые вычисления (меньше итераций для скорости)
      const browserWorkUnits = Math.min(workUnitsRequired, 1000); // Ограничиваем для браузера
      let resultData = null;
      let seed = 0;
      
      // Генерируем seed детерминированно
      for (let i = 0; i < clientId.length; i++) {
        seed = ((seed << 5) - seed + clientId.charCodeAt(i)) & 0xffffffff;
      }
      for (let i = 0; i < contractId.length; i++) {
        seed = ((seed << 5) - seed + contractId.charCodeAt(i)) & 0xffffffff;
      }
      seed = Math.abs(seed) % (2**32);
      
      // Простой генератор случайных чисел (LCG) для детерминированности
      let rng = seed;
      function random() {
        rng = (rng * 1664525 + 1013904223) % (2**32);
        return (rng >>> 0) / (2**32);
      }
      
      // Упрощённые вычисления в зависимости от типа
      if (computationType === 'cosmological') {
        // Упрощённая N-body задача (10 частиц вместо 100)
        const n = 10;
        const particles = [];
        for (let i = 0; i < n; i++) {
          particles.push({ x: random() * 2 - 1, y: random() * 2 - 1, z: random() * 2 - 1, mass: random() + 0.5 });
        }
        for (let step = 0; step < browserWorkUnits; step++) {
          for (let i = 0; i < n; i++) {
            let fx = 0, fy = 0, fz = 0;
            for (let j = 0; j < n; j++) {
              if (i === j) continue;
              const dx = particles[j].x - particles[i].x;
              const dy = particles[j].y - particles[i].y;
              const dz = particles[j].z - particles[i].z;
              const distSq = dx*dx + dy*dy + dz*dz + 0.01;
              const dist = Math.sqrt(distSq);
              const force = particles[i].mass * particles[j].mass / (distSq * dist);
              fx += force * dx;
              fy += force * dy;
              fz += force * dz;
            }
            particles[i].x += fx * 0.01 / particles[i].mass;
            particles[i].y += fy * 0.01 / particles[i].mass;
            particles[i].z += fz * 0.01 / particles[i].mass;
          }
          if (step % 10 === 0) onProgress(step);
        }
        const finalState = `${particles[0].x.toFixed(6)}${particles[0].y.toFixed(6)}`;
        resultData = await sha256Hex(finalState);
      } else if (computationType === 'supernova') {
        // Упрощённое моделирование сверхновой
        let T = 1e9, P = 1e15, rho = 1e6;
        for (let step = 0; step < browserWorkUnits; step++) {
          const dT = -0.1 * T * rho / (1.0 + T/1e8);
          const dP = -0.05 * P * T / 1e9;
          const drho = -0.02 * rho * Math.sqrt(T/1e9);
          T += dT * 0.001;
          P += dP * 0.001;
          rho += drho * 0.001;
          T = Math.max(T, 1e7);
          P = Math.max(P, 1e10);
          rho = Math.max(rho, 1e3);
          if (step % 10 === 0) onProgress(step);
        }
        const finalState = `${T.toExponential(6)}${P.toExponential(6)}${rho.toExponential(6)}`;
        resultData = await sha256Hex(finalState);
      } else if (computationType === 'mhd') {
        // Упрощённая МГД (сетка 5x5x5 вместо 20x20x20)
        const size = 5;
        const Bx = [], By = [], Bz = [];
        for (let i = 0; i < size; i++) {
          Bx[i] = []; By[i] = []; Bz[i] = [];
          for (let j = 0; j < size; j++) {
            Bx[i][j] = []; By[i][j] = []; Bz[i][j] = [];
            for (let k = 0; k < size; k++) {
              Bx[i][j][k] = random() * 2 - 1;
              By[i][j][k] = random() * 2 - 1;
              Bz[i][j][k] = random() * 2 - 1;
            }
          }
        }
        for (let step = 0; step < browserWorkUnits; step++) {
          for (let i = 1; i < size-1; i++) {
            for (let j = 1; j < size-1; j++) {
              for (let k = 1; k < size-1; k++) {
                const dBx = (Bx[i+1][j][k] - Bx[i-1][j][k]) / 2.0 * 0.1;
                const dBy = (By[i][j+1][k] - By[i][j-1][k]) / 2.0 * 0.1;
                const dBz = (Bz[i][j][k+1] - Bz[i][j][k-1]) / 2.0 * 0.1;
                Bx[i][j][k] += dBx * 0.001;
                By[i][j][k] += dBy * 0.001;
                Bz[i][j][k] += dBz * 0.001;
              }
            }
          }
          if (step % 10 === 0) onProgress(step);
        }
        const finalState = `${Bx[2][2][2].toFixed(6)}${By[2][2][2].toFixed(6)}${Bz[2][2][2].toFixed(6)}`;
        resultData = await sha256Hex(finalState);
      } else if (computationType === 'radiative') {
        // Упрощённый радиационный перенос
        const nAngles = 5, nFreq = 10, nPoints = 20;
        const I = [];
        for (let a = 0; a < nAngles; a++) {
          I[a] = [];
          for (let f = 0; f < nFreq; f++) {
            I[a][f] = [];
            for (let p = 0; p < nPoints; p++) {
              I[a][f][p] = random();
            }
          }
        }
        for (let step = 0; step < browserWorkUnits; step++) {
          for (let a = 0; a < nAngles; a++) {
            const angle = a * Math.PI / nAngles;
            const cosAngle = Math.cos(angle);
            for (let f = 0; f < nFreq; f++) {
              const freq = f * 0.1;
              for (let p = 1; p < nPoints; p++) {
                const dI = -I[a][f][p] * (1.0 + freq);
                const source = 0.1 * Math.exp(-freq) * (1.0 + cosAngle);
                I[a][f][p] += (dI + source) * 0.01;
                I[a][f][p] = Math.max(0, I[a][f][p]);
              }
            }
          }
          if (step % 10 === 0) onProgress(step);
        }
        let total = 0;
        for (let a = 0; a < nAngles; a++) {
          for (let f = 0; f < nFreq; f++) {
            for (let p = 0; p < nPoints; p++) {
              total += I[a][f][p];
            }
          }
        }
        const finalState = total.toExponential(6);
        resultData = await sha256Hex(finalState);
      } else if (computationType === 'gravitational_waves') {
        // Упрощённые гравитационные волны (сетка 10x10 вместо 30x30)
        const size = 10;
        let hPlus = [], hCross = [];
        for (let i = 0; i < size; i++) {
          hPlus[i] = []; hCross[i] = [];
          for (let j = 0; j < size; j++) {
            hPlus[i][j] = (random() - 0.5) * 0.02;
            hCross[i][j] = (random() - 0.5) * 0.02;
          }
        }
        const dt = 0.001, dx = 0.1;
        for (let step = 0; step < browserWorkUnits; step++) {
          const hPlusNew = [], hCrossNew = [];
          for (let i = 0; i < size; i++) {
            hPlusNew[i] = []; hCrossNew[i] = [];
            for (let j = 0; j < size; j++) {
              if (i > 0 && i < size-1 && j > 0 && j < size-1) {
                const d2h_dx2_p = (hPlus[i+1][j] - 2*hPlus[i][j] + hPlus[i-1][j]) / (dx*dx);
                const d2h_dy2_p = (hPlus[i][j+1] - 2*hPlus[i][j] + hPlus[i][j-1]) / (dx*dx);
                const d2h_dx2_c = (hCross[i+1][j] - 2*hCross[i][j] + hCross[i-1][j]) / (dx*dx);
                const d2h_dy2_c = (hCross[i][j+1] - 2*hCross[i][j] + hCross[i][j-1]) / (dx*dx);
                hPlusNew[i][j] = hPlus[i][j] + dt * (d2h_dx2_p + d2h_dy2_p);
                hCrossNew[i][j] = hCross[i][j] + dt * (d2h_dx2_c + d2h_dy2_c);
              } else {
                hPlusNew[i][j] = hPlus[i][j];
                hCrossNew[i][j] = hCross[i][j];
              }
            }
          }
          hPlus = hPlusNew;
          hCross = hCrossNew;
          if (step % 10 === 0) onProgress(step);
        }
        const amplitude = Math.sqrt(hPlus[5][5]**2 + hCross[5][5]**2);
        const finalState = amplitude.toExponential(6);
        resultData = await sha256Hex(finalState);
      } else {
        // Fallback: используем простой PoW
        return await runPoW(clientId, contractId, Math.min(workUnitsRequired, 1000), 3, onProgress);
      }
      
      return { 
        work_units_done: browserWorkUnits, 
        result_data: resultData, 
        nonce: String(seed) 
      };
    }

    function getApiKey() {
      const sel = document.getElementById('select-client').value;
      if (sel) {
        const c = getSavedClients().find(x => x.id === sel);
        if (c && c.apiKey) return c.apiKey;
      }
      const k1 = document.getElementById('input-api-key').value.trim();
      // Убрано дублирование: используем только поле из вкладки "Обзор"
      return k1;
    }
    function getSelectedClientId() {
      const v = document.getElementById('select-client').value;
      return v || null;
    }
    function setInlineMsg(el, level, text) {
      if (!el) return;
      el.className = 'msg ' + (level || 'info');
      el.textContent = text || '';
      el.style.display = text ? 'block' : 'none';
    }
    const DEFAULT_DIFFICULTY_BY_COMPUTATION = {
      simple_pow: 3,
      cosmological: 5,
      supernova: 5,
      mhd: 4,
      radiative: 4,
      gravitational_waves: 6,
      molecular_dynamics_benchpep: 4
    };
    const PROVIDER_CATEGORY_PRESETS = {
      modeling_simulations: {
        label: 'Моделирование и симуляции',
        computationType: 'cosmological',
        defaultDifficulty: 5
      },
      biomedicine: {
        label: 'Биомедицина',
        computationType: 'supernova',
        defaultDifficulty: 5
      },
      artificial_intelligence: {
        label: 'Искусственный интеллект',
        computationType: 'mhd',
        defaultDifficulty: 4
      },
      data_analysis: {
        label: 'Анализ данных',
        computationType: 'simple_pow',
        defaultDifficulty: 3
      },
      molecular_dynamics: {
        label: 'Молекулярная динамика (benchPEP)',
        computationType: 'molecular_dynamics_benchpep',
        defaultDifficulty: 4
      }
    };
    const SUPPORTED_BUDGET_CURRENCIES = ['RUB', 'USD', 'EUR'];
    function formatWalletBalances(balances) {
      const safe = balances || {};
      return SUPPORTED_BUDGET_CURRENCIES.map(cur => cur + ': ' + (safe[cur] ?? 0)).join(' · ');
    }
    async function marketApi(path, { method = 'GET', payload = null } = {}) {
      const apiKey = getApiKey();
      if (!apiKey) throw new Error('Выберите вычислителя с API-ключом на вкладке «Обзор».');
      const options = {
        method,
        headers: {
          'Authorization': 'Bearer ' + apiKey
        }
      };
      if (payload !== null) {
        options.headers['Content-Type'] = 'application/json';
        options.body = JSON.stringify(payload);
      }
      const response = await fetch(base + path, options);
      const data = await response.json().catch(() => ({}));
      if (!response.ok) throw new Error(data.error || ('HTTP ' + response.status));
      return data;
    }
    /** Сброс вкладки «Работа» при смене вычислителя: задача и блок воркера скрыты, подсказка — получить задачу заново. */
    function clearWorkPanelForNewAccount() {
      currentTask = null;
      workPanelAccountId = null;
      const specEl = document.getElementById('work-task-spec');
      const bodyEl = document.getElementById('work-task-body');
      const workerBlock = document.getElementById('work-run-in-worker');
      const msg = document.getElementById('work-task-msg');
      const runBtn = document.getElementById('btn-run-work');
      if (specEl) specEl.style.display = 'none';
      if (bodyEl) bodyEl.innerHTML = '';
      if (workerBlock) workerBlock.style.display = 'none';
      if (msg) {
        msg.className = 'msg info';
        msg.textContent = '⚠️ Вычислитель изменён. Предыдущая задача была сброшена, так как она была получена для другого вычислителя. Нажмите «Получить задачу» для текущего вычислителя.';
        msg.style.display = 'block';
      }
      if (runBtn) runBtn.disabled = true;
      const resultEl = document.getElementById('work-result');
      const progressEl = document.getElementById('work-progress');
      if (resultEl) { resultEl.style.display = 'none'; resultEl.textContent = ''; }
      if (progressEl) progressEl.style.display = 'none';
      const runWorkerMsg = document.getElementById('work-run-worker-msg');
      const statusHint = document.getElementById('work-worker-status-hint');
      const balanceResult = document.getElementById('work-worker-balance-result');
      if (runWorkerMsg) { runWorkerMsg.style.display = 'none'; runWorkerMsg.textContent = ''; }
      if (statusHint) statusHint.style.display = 'none';
      if (balanceResult) { balanceResult.style.display = 'none'; balanceResult.textContent = ''; }
    }

    /**
     * Установка текущей задачи и отображение её в интерфейсе.
     * Сохраняет задачу в localStorage для восстановления при перезагрузке страницы.
     * @param {Object} task - Объект задачи с полями contract_id, work_units_required, difficulty и т.д.
     */
    function setCurrentTask(task) {
      currentTask = task;
      workPanelAccountId = getSelectedClientId();
      
      // Сохраняем задачу в localStorage для восстановления при перезагрузке
      saveCurrentTask();
      
      const specEl = document.getElementById('work-task-spec');
      const bodyEl = document.getElementById('work-task-body');
      const runBtn = document.getElementById('btn-run-work');
      const msg = document.getElementById('work-task-msg');
      specEl.style.display = 'block';
      
      // Формируем HTML с информацией о задаче
      const taskName = task.task_name || task.contract_id || '';
      const taskDesc = task.task_description || '';
      const taskCategory = task.task_category || '';
      let html = '';
      if (taskName) html += '<strong>Название:</strong> ' + taskName + '<br>';
      if (taskCategory) html += '<strong>Категория:</strong> ' + taskCategory + '<br>';
      if (taskDesc) html += '<strong>Описание:</strong> ' + taskDesc + '<br>';
      html += '<strong>Contract ID:</strong> ' + (task.contract_id || '') + '<br>';
      html += '<strong>Work units required:</strong> ' + (task.work_units_required ?? '') + '<br>';
      html += '<strong>Difficulty:</strong> ' + (task.difficulty ?? '') + '<br>';
      if (task.reward_per_task != null) {
        html += '<strong>Награда:</strong> ' + task.reward_per_task + ' ' + (task.reward_currency || 'RUB') + '<br>';
      }
      if (task.computation_type) html += '<strong>Тип вычислений:</strong> ' + task.computation_type;
      bodyEl.innerHTML = html;
      
      runBtn.disabled = false;
      msg.className = 'msg ok';
      msg.textContent = 'Задача: ' + (taskName || task.contract_id || '') + ', единиц работы: ' + (task.work_units_required ?? '');
      msg.style.display = 'block';
      
      // Блок «Выполнить в воркере»: команда с CONTRACT_ID
      const cid = task.contract_id || '';
      const workerBlock = document.getElementById('work-run-in-worker');
      const cmdEl = document.getElementById('work-worker-cmd');
      const cidEl = document.getElementById('work-worker-cid');
      if (cid && workerBlock && cmdEl && cidEl) {
        workerBlock.style.display = 'block';
        updateWorkerCmd();
        cidEl.textContent = cid;
      } else if (workerBlock) {
        workerBlock.style.display = 'none';
      }
    }

    function updateWorkerCmd() {
      const cmdEl = document.getElementById('work-worker-cmd');
      const winOnceEl = document.getElementById('work-worker-win-once');
      const cid = (currentTask && currentTask.contract_id) ? currentTask.contract_id : '';
      const runOnce = document.getElementById('work-worker-mode-once') && document.getElementById('work-worker-mode-once').checked;
      if (!cmdEl || !cid) return;
      let cmd = 'CONTRACT_ID=' + cid;
      if (runOnce) cmd += ' RUN_ONCE=1';
      cmd += ' docker-compose run --rm client_worker_1';
      cmdEl.textContent = cmd;
      if (winOnceEl) winOnceEl.textContent = runOnce ? ' && set RUN_ONCE=1' : '';
    }

    (function() {
      const onceRadio = document.getElementById('work-worker-mode-once');
      const loopRadio = document.getElementById('work-worker-mode-loop');
      if (onceRadio) onceRadio.addEventListener('change', updateWorkerCmd);
      if (loopRadio) loopRadio.addEventListener('change', updateWorkerCmd);
    })();

    let workProgressIntervalId = null;
    async function fetchWorkerProgress() {
      const key = getApiKey();
      const card = document.getElementById('profile-worker-progress-card');
      const textEl = document.getElementById('profile-worker-progress-text');
      const bar = document.getElementById('profile-worker-progress-bar');
      const noTaskEl = document.getElementById('profile-worker-no-task');
      if (!card || !textEl || !bar) return;
      if (!key) { card.style.display = 'none'; if (noTaskEl) noTaskEl.style.display = 'none'; return; }
      try {
        const r = await fetch(base + '/worker_progress', { headers: { 'Authorization': 'Bearer ' + key } });
        const data = await r.json().catch(() => ({}));
        const p = data.progress;
        if (!p || p.total <= 0) {
          card.style.display = 'block';
          if (noTaskEl) { noTaskEl.style.display = 'block'; }
          textEl.style.display = 'none';
          bar.style.display = 'none';
          return;
        }
        if (noTaskEl) noTaskEl.style.display = 'none';
        textEl.style.display = 'block';
        bar.style.display = 'block';
        const pct = Math.min(100, Math.round(100.0 * p.step / p.total));
        bar.value = pct;
        bar.max = 100;
        if (p.step >= p.total) {
          textEl.textContent = 'Задача выполнена (100%) — контракт ' + (p.contract_id || '') + '. Сдача результата или ожидание следующей задачи.';
        } else {
          textEl.textContent = 'Активная задача: контракт ' + (p.contract_id || '') + ' — ' + pct + '% (' + p.step + ' / ' + p.total + ' ед. работы).';
        }
        card.style.display = 'block';
      } catch (e) {
        card.style.display = 'none';
        if (noTaskEl) noTaskEl.style.display = 'none';
      }
    }
    function startWorkerProgressPolling() {
      stopWorkerProgressPolling();
      fetchWorkerProgress();
      workProgressIntervalId = setInterval(fetchWorkerProgress, 2000);
    }
    function stopWorkerProgressPolling() {
      if (workProgressIntervalId) { clearInterval(workProgressIntervalId); workProgressIntervalId = null; }
    }

    document.getElementById('btn-copy-worker-cmd').onclick = function() {
      const cmdEl = document.getElementById('work-worker-cmd');
      if (!cmdEl || !cmdEl.textContent) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(cmdEl.textContent).then(() => { this.textContent = 'Скопировано'; setTimeout(() => { this.textContent = 'Копировать'; }, 1500); }).catch(() => {});
      } else {
        const sel = window.getSelection();
        const r = document.createRange();
        r.selectNodeContents(cmdEl);
        sel.removeAllRanges();
        sel.addRange(r);
        try { document.execCommand('copy'); this.textContent = 'Скопировано'; setTimeout(() => { this.textContent = 'Копировать'; }, 1500); } catch (e) {}
        sel.removeAllRanges();
      }
    };

    document.getElementById('btn-start-worker').onclick = async function() {
      const key = getApiKey();
      const msgEl = document.getElementById('work-run-worker-msg');
      msgEl.style.display = 'none';
      if (!key) { msgEl.className = 'msg err'; msgEl.textContent = 'Выберите вычислителя или введите API-ключ.'; msgEl.style.display = 'block'; return; }
      if (!currentTask || !currentTask.contract_id) { msgEl.className = 'msg err'; msgEl.textContent = 'Сначала получите или выберите задачу.'; msgEl.style.display = 'block'; return; }
      const sel = document.getElementById('select-client').value;
      const list = getSavedClients();
      const selectedClient = list.find(function(c) { return c.id === sel; });
      const runOnce = document.getElementById('work-worker-mode-once') && document.getElementById('work-worker-mode-once').checked;
      const body = { contract_id: currentTask.contract_id, run_once: runOnce };
      if (selectedClient && selectedClient.client_id) body.client_id = selectedClient.client_id;
      this.disabled = true;
      try {
        const r = await fetch(base + '/run_worker', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + key },
          body: JSON.stringify(body)
        });
        const data = await r.json().catch(() => ({}));
        msgEl.style.display = 'block';
        if (r.status === 202) {
          msgEl.className = 'msg ok';
          var who = (selectedClient && selectedClient.label) ? selectedClient.label : 'вычислитель';
          if (data.client_id) who += ' (ID: ' + (data.client_id.length > 8 ? data.client_id.slice(0, 8) + '…' : data.client_id) + ')';
          msgEl.textContent = (data.message || 'Воркер запущен. ') + ' Награда будет начислена на: ' + who + '.';
          document.getElementById('work-worker-status-hint').style.display = 'block';
          document.getElementById('work-worker-balance-result').style.display = 'none';
        } else {
          document.getElementById('work-worker-status-hint').style.display = 'none';
          msgEl.className = 'msg err';
          var errText = data.error || '';
          if (data.detail) errText += (errText ? ': ' : '') + data.detail;
          if (!errText) errText = r.status + ' ' + r.statusText;
          msgEl.textContent = errText;
          if (data.detail && (String(data.detail).toLowerCase().indexOf('image') !== -1 || String(data.detail).indexOf('not found') !== -1)) {
            msgEl.textContent += ' Подсказка: в папке проекта выполните docker-compose build, затем повторите.';
          } else if (data.detail && (String(data.detail).toLowerCase().indexOf('docker') !== -1 || String(data.detail).toLowerCase().indexOf('socket') !== -1)) {
            msgEl.textContent += ' Подсказка: убедитесь, что Docker Desktop запущен и контейнеры подняты через start.bat (docker-compose).';
          }
        }
      } catch (e) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Ошибка: ' + e.message;
        msgEl.style.display = 'block';
      }
      this.disabled = false;
    };

    document.getElementById('btn-check-balance-after-worker').onclick = async function() {
      const key = getApiKey();
      const resultEl = document.getElementById('work-worker-balance-result');
      resultEl.style.display = 'none';
      if (!key) { resultEl.className = 'msg err'; resultEl.textContent = 'Выберите вычислителя или введите API-ключ.'; resultEl.style.display = 'block'; return; }
      try {
        const meRes = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + key } });
        const meData = await meRes.json();
        if (!meRes.ok) throw new Error(meData.error || 'Неверный ключ');
        const walletRes = await fetch(base + '/market/wallet', { headers: { 'Authorization': 'Bearer ' + key } });
        const walletData = await walletRes.json();
        if (!walletRes.ok) throw new Error(walletData.error || walletRes.status);
        resultEl.className = 'msg ok';
        resultEl.textContent = 'Кошелёк: ' + formatWalletBalances(walletData.balances || {}) + ' · Chain points: ' + (meData.balance ?? 0);
        resultEl.style.display = 'block';
      } catch (e) {
        resultEl.className = 'msg err';
        resultEl.textContent = 'Ошибка: ' + e.message;
        resultEl.style.display = 'block';
      }
    };

    document.getElementById('btn-get-task').onclick = async () => {
      const key = getApiKey();
      const msg = document.getElementById('work-task-msg');
      const btn = document.getElementById('btn-get-task');
      msg.style.display = 'none';
      if (!key) { 
        msg.className = 'msg err'; 
        msg.textContent = '❌ Выберите вычислителя на вкладке «Обзор» или введите API-ключ там.'; 
        msg.style.display = 'block'; 
        return; 
      }
      btn.disabled = true;
      btn.textContent = 'Загрузка...';
      try {
        const r = await fetch(base + '/get_task', { headers: { 'Authorization': 'Bearer ' + key } });
        const task = await r.json();
        if (!r.ok) {
          if (r.status === 401) {
            throw new Error('Неверный API-ключ. Проверьте ключ на вкладке «Обзор».');
          } else {
            throw new Error(task.error || 'Ошибка сервера: ' + r.status);
          }
        }
        setCurrentTask(task);
      } catch (e) {
        msg.className = 'msg err';
        msg.textContent = '❌ Ошибка получения задачи: ' + e.message + ' Проверьте, что выбран вычислитель и API-ключ правильный.';
        msg.style.display = 'block';
      } finally {
        btn.disabled = false;
        btn.textContent = 'Получить задачу';
      }
    };

    document.getElementById('btn-run-work').onclick = async () => {
      const key = getApiKey();
      if (!key) { document.getElementById('work-result').className = 'msg err'; document.getElementById('work-result').textContent = 'Введите API-ключ.'; document.getElementById('work-result').style.display = 'block'; return; }
      if (!currentTask) { document.getElementById('work-result').className = 'msg err'; document.getElementById('work-result').textContent = 'Сначала нажмите «Получить задачу».'; document.getElementById('work-result').style.display = 'block'; return; }
      const runBtn = document.getElementById('btn-run-work');
      const progressEl = document.getElementById('work-progress');
      const resultEl = document.getElementById('work-result');
      runBtn.disabled = true;
      progressEl.style.display = 'block';
      progressEl.textContent = 'Получение client_id…';
      resultEl.style.display = 'none';
      try {
        const meRes = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + key } });
        const meData = await meRes.json();
        if (!meRes.ok) throw new Error(meData.error || 'Неверный API-ключ');
        const clientId = meData.client_id;
        const targetWork = parseInt(currentTask.work_units_required, 10) || 0;
        const difficulty = parseInt(currentTask.difficulty, 10) || 0;
        const computationType = currentTask.computation_type || 'simple_pow';
        if (computationType === 'molecular_dynamics_benchpep') {
          progressEl.style.display = 'none';
          runBtn.disabled = false;
          resultEl.className = 'msg info';
          resultEl.innerHTML = 'Для molecular dynamics (benchPEP) используйте Desktop Agent. ' +
            '<a href="/download/desktop-agent" target="_blank" rel="noopener">Скачать дистрибутив</a>.';
          resultEl.style.display = 'block';
          return;
        }
        
        // Выбираем тип вычислений
        let result;
          // Предупреждение для астрофизических задач
          if (computationType !== 'simple_pow' && targetWork > 1000) {
            const taskName = currentTask.task_name || currentTask.contract_id || '';
            const confirmMsg = 'Для задачи "' + taskName + '" требуется выполнить ' + targetWork + ' единиц работы.\n\n' +
              'В браузере будет выполнена упрощённая версия (1000 единиц) для демонстрации.\n' +
              'Для получения награды используйте воркер (кнопка «Запустить воркер автоматически»).\n\n' +
              'Продолжить с упрощённой версией?';
            if (!confirm(confirmMsg)) {
              progressEl.style.display = 'none';
              runBtn.disabled = false;
              return;
            }
          }
          
          if (computationType === 'simple_pow') {
          progressEl.textContent = 'Вычисление PoW (0 из ' + targetWork + ')…';
          result = await runPoW(clientId, currentTask.contract_id, targetWork, difficulty, (n) => {
            progressEl.textContent = 'Вычисление PoW (' + n + ' из ' + targetWork + ')…';
          });
        } else {
          // Астрофизические задачи: используем упрощённые вычисления для браузера
          const taskName = currentTask.task_name || currentTask.contract_id || '';
          const browserWorkUnits = Math.min(targetWork, 1000); // Ограничиваем для браузера
          progressEl.textContent = 'Вычисление: ' + taskName + ' (0 из ' + browserWorkUnits + ', упрощённая версия)…';
          result = await runAstrophysicsComputation(clientId, currentTask.contract_id, browserWorkUnits, computationType, (n) => {
            progressEl.textContent = 'Вычисление: ' + taskName + ' (' + n + ' из ' + browserWorkUnits + ', упрощённая версия)…';
          });
          // Отправляем реальный объём выполненной работы (для браузера это упрощённая версия)
          // Примечание: для полных вычислений используйте воркер
        }
        
        // Проверяем, достаточно ли работы выполнено для астрофизических задач
        if (computationType !== 'simple_pow' && result.work_units_done < targetWork) {
          // Для астрофизических задач в браузере выполняется упрощённая версия
          progressEl.style.display = 'none';
          runBtn.disabled = false;
          resultEl.className = 'msg info';
          resultEl.textContent = 'ℹ️ Выполнено ' + result.work_units_done + ' из ' + targetWork + ' единиц работы (упрощённая версия для браузера). ' +
            'Для получения награды требуется выполнить полный объём работы — используйте воркер (кнопка «Запустить воркер автоматически» выше). Результат не отправлен.';
          resultEl.style.display = 'block';
          return;
        }
        
        progressEl.textContent = 'Отправка результата на сервер (это может занять до 15 минут для больших задач)…';
        const subRes = await fetch(base + '/submit_work', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + key },
          body: JSON.stringify({
            client_id: clientId,
            contract_id: currentTask.contract_id,
            work_units_done: result.work_units_done,
            result_data: result.result_data,
            nonce: result.nonce
          })
        });
        const subData = await subRes.json();
        progressEl.style.display = 'none';
        runBtn.disabled = false;
        if (!subRes.ok) {
          let errorMsg = subData.error || 'Ошибка сервера: ' + subRes.status;
          if (subRes.status === 401) {
            errorMsg = 'Неверный API-ключ. Проверьте ключ на вкладке «Обзор».';
          } else if (subRes.status === 400) {
            errorMsg = 'Ошибка валидации: ' + (subData.error || 'неверные данные');
          } else if (subRes.status === 409) {
            errorMsg = 'Эта задача уже была сдана другим вычислителем. Получите новую задачу.';
          }
          throw new Error(errorMsg);
        }
        resultEl.className = 'msg ok';
        const rewardCurrency = subData.reward_currency || 'RUB';
        resultEl.textContent = '✅ Работа принята. Начислено: ' + (subData.reward_issued ?? '') + ' ' + rewardCurrency + '. Проверьте fiat-кошелёк во вкладке «Профиль».';
        resultEl.style.display = 'block';
      } catch (e) {
        progressEl.style.display = 'none';
        runBtn.disabled = false;
        resultEl.className = 'msg err';
        resultEl.textContent = 'Ошибка: ' + e.message;
        resultEl.style.display = 'block';
      }
    };

    document.getElementById('btn-balance').onclick = async () => {
      const key = document.getElementById('input-api-key').value.trim();
      const msg = document.getElementById('balance-msg');
      msg.style.display = 'none';
      if (!key) { msg.className = 'msg err'; msg.textContent = 'Введите api_key'; msg.style.display = 'block'; return; }
      try {
        const meRes = await fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + key } });
        const meData = await meRes.json();
        if (!meRes.ok) throw new Error(meData.error || meRes.status);
        const walletRes = await fetch(base + '/market/wallet', {
          headers: { 'Authorization': 'Bearer ' + key }
        });
        const walletData = await walletRes.json();
        if (!walletRes.ok) throw new Error(walletData.error || walletRes.status);
        msg.className = 'msg ok';
        msg.textContent = 'Кошелёк: ' + formatWalletBalances(walletData.balances || {}) + ' · Chain points: ' + (meData.balance ?? 0);
        msg.style.display = 'block';
      } catch (e) {
        msg.className = 'msg err';
        msg.textContent = 'Ошибка: ' + e.message;
        msg.style.display = 'block';
      }
    };

    let providerSectors = [];

    async function providerApi(path, { method = 'GET', payload = null } = {}) {
      const apiKey = getApiKey();
      if (!apiKey) throw new Error('Выберите вычислителя с API-ключом на вкладке «Обзор».');
      const options = {
        method,
        headers: {
          'Authorization': 'Bearer ' + apiKey
        }
      };
      if (payload !== null) {
        options.headers['Content-Type'] = 'application/json';
        options.body = JSON.stringify(payload);
      }
      const response = await fetch(base + path, options);
      const data = await response.json().catch(() => ({}));
      if (!response.ok) throw new Error(data.error || ('HTTP ' + response.status));
      return data;
    }

    function getSelectedSectorId() {
      const select = document.getElementById('provider-sector-select');
      if (!select) return '';
      return (select.value || '').trim();
    }

    function getSelectedSectorRecord() {
      const sectorId = getSelectedSectorId();
      if (!sectorId) return null;
      return (providerSectors || []).find((s) => s.sector_id === sectorId) || null;
    }

    function renderProviderSectorInfo(contractsList = null) {
      const infoCard = document.getElementById('provider-sector-info-card');
      const nameEl = document.getElementById('provider-sector-info-name');
      const orgEl = document.getElementById('provider-sector-info-org');
      const domainEl = document.getElementById('provider-sector-info-domain');
      const contractsEl = document.getElementById('provider-sector-info-contracts');
      const activeEl = document.getElementById('provider-sector-info-active');
      const budgetEl = document.getElementById('provider-sector-info-budget');
      const sector = getSelectedSectorRecord();
      if (!sector) {
        if (infoCard) infoCard.style.display = 'none';
        return;
      }
      if (infoCard) infoCard.style.display = 'block';
      if (nameEl) nameEl.textContent = sector.sector_name || sector.sector_id || '-';
      if (orgEl) orgEl.textContent = sector.organization_name || '-';
      if (domainEl) domainEl.textContent = sector.compute_domain || '-';

      const list = Array.isArray(contractsList) ? contractsList : [];
      const activeCount = list.filter((c) => c.status === 'active').length;
      const budgetByCurrency = {};
      list.forEach((c) => {
        const currency = c.budget_currency || c.reward_currency || 'RUB';
        const amount = Number(c.budget_tokens_available || 0);
        budgetByCurrency[currency] = (budgetByCurrency[currency] || 0) + amount;
      });
      const budgetText = Object.keys(budgetByCurrency).length
        ? Object.entries(budgetByCurrency).map(([cur, value]) => `${value} ${cur}`).join(' · ')
        : '0';
      if (contractsEl) contractsEl.textContent = String(list.length);
      if (activeEl) activeEl.textContent = String(activeCount);
      if (budgetEl) budgetEl.textContent = budgetText;
    }

    function renderSectorOptions(sectors) {
      const select = document.getElementById('provider-sector-select');
      if (!select) return;
      const prev = (select.value || '').trim();
      select.innerHTML = '';
      if (!sectors || !sectors.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Сначала создайте сектор';
        select.appendChild(opt);
        select.value = '';
        return;
      }
      sectors.forEach((sector) => {
        const opt = document.createElement('option');
        opt.value = sector.sector_id;
        const domain = sector.compute_domain ? (' · ' + sector.compute_domain) : '';
        opt.textContent = (sector.sector_name || sector.sector_id) + domain;
        select.appendChild(opt);
      });
      const hasPrev = sectors.some((s) => s.sector_id === prev);
      select.value = hasPrev ? prev : sectors[0].sector_id;
    }

    function refreshProviderCreateVisibility() {
      const sectorId = getSelectedSectorId();
      const createCard = document.getElementById('provider-contract-create-card');
      const requiredMsg = document.getElementById('provider-sector-required-msg');
      const createBtn = document.getElementById('btn-provider-create');
      const hasSector = !!sectorId;
      if (createCard) createCard.style.display = hasSector ? 'block' : 'none';
      if (requiredMsg) requiredMsg.style.display = hasSector ? 'none' : 'block';
      if (createBtn) createBtn.disabled = !hasSector || !getApiKey();
      renderProviderSectorInfo();
    }

    async function loadProviderSectors(showMessage = false) {
      const msgEl = document.getElementById('provider-sector-msg');
      try {
        providerSectors = await providerApi('/provider/sectors');
        renderSectorOptions(providerSectors || []);
        refreshProviderCreateVisibility();
        if (showMessage) setInlineMsg(msgEl, 'ok', 'Секторы обновлены.');
      } catch (e) {
        providerSectors = [];
        renderSectorOptions([]);
        refreshProviderCreateVisibility();
        if (showMessage) setInlineMsg(msgEl, 'err', 'Ошибка загрузки секторов: ' + e.message);
      }
    }

    function loadProviderPanel() {
      const hasKey = !!getApiKey();
      const authRequired = document.getElementById('provider-auth-required');
      const createBtn = document.getElementById('btn-provider-create');
      const refreshBtn = document.getElementById('btn-provider-refresh');
      const createSectorBtn = document.getElementById('btn-provider-sector-create');
      const refreshSectorsBtn = document.getElementById('btn-provider-sectors-refresh');
      if (authRequired) authRequired.style.display = hasKey ? 'none' : 'block';
      if (createBtn) createBtn.disabled = !hasKey;
      if (refreshBtn) refreshBtn.disabled = !hasKey;
      if (createSectorBtn) createSectorBtn.disabled = !hasKey;
      if (refreshSectorsBtn) refreshSectorsBtn.disabled = !hasKey;
      if (!hasKey) {
        refreshProviderCreateVisibility();
        const loadEl = document.getElementById('provider-load');
        const emptyEl = document.getElementById('provider-empty');
        const table = document.getElementById('table-provider-contracts');
        if (loadEl) loadEl.style.display = 'none';
        if (emptyEl) emptyEl.style.display = 'block';
        if (table) table.style.display = 'none';
        if (emptyEl) emptyEl.textContent = 'Для просмотра ваших секторов и контрактов выберите аккаунт на вкладке «Обзор».';
        renderProviderSectorInfo([]);
        return;
      }
      loadProviderSectors().then(loadProviderContracts);
    }

    function renderProviderContracts(list) {
      const table = document.getElementById('table-provider-contracts');
      const tbody = table.querySelector('tbody');
      const emptyEl = document.getElementById('provider-empty');
      tbody.innerHTML = '';
      (list || []).forEach(contract => {
        const progress = contract.completion_pct != null ? contract.completion_pct + '%' : '-';
        const budget = contract.budget_tokens_available != null ? contract.budget_tokens_available : '-';
        const reward = contract.reward_per_task != null ? contract.reward_per_task : '-';
        const currency = contract.budget_currency || contract.reward_currency || 'RUB';
        const row = document.createElement('tr');
        row.innerHTML =
          '<td class="mono">' + (contract.contract_id || '-') + '</td>' +
          '<td>' + (contract.sector_name || contract.sector_id || '-') + '</td>' +
          '<td><strong>' + (contract.task_name || '-') + '</strong></td>' +
          '<td>' + (contract.status || '-') + '</td>' +
          '<td>' + reward + ' ' + currency + '</td>' +
          '<td>' + progress + '</td>' +
          '<td>' + budget + ' ' + currency + '</td>' +
          '<td>' +
            '<div class="row" style="gap:6px;">' +
              '<select data-provider-status style="min-width:120px;">' +
                '<option value="active">active</option>' +
                '<option value="paused">paused</option>' +
                '<option value="closed">closed</option>' +
                '<option value="draft">draft</option>' +
              '</select>' +
              '<button type="button" class="primary" data-provider-apply-status>Статус</button>' +
            '</div>' +
            '<div class="row" style="gap:6px; margin-top:6px;">' +
              '<input type="number" min="1" step="1" placeholder="Сумма (' + currency + ')" data-provider-fund style="min-width:120px;">' +
              '<button type="button" class="primary" data-provider-fund-btn>Пополнить</button>' +
              '<button type="button" data-provider-refund-btn>Вернуть</button>' +
            '</div>' +
          '</td>';
        tbody.appendChild(row);
        const statusSelect = row.querySelector('[data-provider-status]');
        const applyBtn = row.querySelector('[data-provider-apply-status]');
        const fundInput = row.querySelector('[data-provider-fund]');
        const fundBtn = row.querySelector('[data-provider-fund-btn]');
        const refundBtn = row.querySelector('[data-provider-refund-btn]');
        statusSelect.value = contract.status || 'draft';

        applyBtn.onclick = async () => {
          try {
            await providerApi('/provider/contracts/' + encodeURIComponent(contract.contract_id) + '/status', {
              method: 'POST',
              payload: { status: statusSelect.value }
            });
            await loadProviderContracts();
            loadContracts();
          } catch (e) {
            alert('Ошибка смены статуса: ' + e.message);
          }
        };
        fundBtn.onclick = async () => {
          const amount = parseInt(fundInput.value, 10);
          if (!amount || amount < 1) { alert('Укажите сумму пополнения (>= 1).'); return; }
          try {
            await providerApi('/provider/contracts/' + encodeURIComponent(contract.contract_id) + '/fund', {
              method: 'POST',
              payload: { amount, currency }
            });
            fundInput.value = '';
            await loadProviderContracts();
            loadContracts();
          } catch (e) {
            alert('Ошибка пополнения: ' + e.message);
          }
        };
        refundBtn.onclick = async () => {
          if (!confirm('Вернуть весь доступный остаток по контракту ' + contract.contract_id + '?')) return;
          try {
            await providerApi('/provider/contracts/' + encodeURIComponent(contract.contract_id) + '/refund', {
              method: 'POST',
              payload: {}
            });
            await loadProviderContracts();
            loadContracts();
          } catch (e) {
            alert('Ошибка возврата: ' + e.message);
          }
        };
      });
      table.style.display = list && list.length ? 'table' : 'none';
      emptyEl.style.display = list && list.length ? 'none' : 'block';
      if (!list || !list.length) emptyEl.textContent = 'Контрактов пока нет.';
      renderProviderSectorInfo(list || []);
    }

    async function loadProviderContracts() {
      const loadEl = document.getElementById('provider-load');
      const msgEl = document.getElementById('provider-create-msg');
      const emptyEl = document.getElementById('provider-empty');
      const table = document.getElementById('table-provider-contracts');
      loadEl.style.display = 'block';
      emptyEl.style.display = 'none';
      table.style.display = 'none';
      try {
        const sectorId = getSelectedSectorId();
        if (!sectorId) {
          loadEl.style.display = 'none';
          emptyEl.style.display = 'block';
          emptyEl.textContent = 'Сначала создайте и выберите сектор.';
          renderProviderSectorInfo([]);
          return;
        }
        const path = '/provider/contracts?sector_id=' + encodeURIComponent(sectorId);
        const list = await providerApi(path);
        loadEl.style.display = 'none';
        renderProviderContracts(list || []);
      } catch (e) {
        loadEl.style.display = 'none';
        table.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Ошибка загрузки: ' + e.message;
        setInlineMsg(msgEl, 'err', 'Не удалось загрузить контракты поставщика.');
      }
    }

    document.getElementById('provider-computation-type').addEventListener('change', function() {
      const difficultyEl = document.getElementById('provider-difficulty');
      const categoryEl = document.getElementById('provider-task-category');
      const preset = PROVIDER_CATEGORY_PRESETS[this.value] || PROVIDER_CATEGORY_PRESETS.data_analysis;
      if (!difficultyEl.value) {
        difficultyEl.value = preset.defaultDifficulty;
      }
      if (categoryEl && !categoryEl.value.trim()) categoryEl.value = preset.label;
    });

    document.getElementById('btn-provider-refresh').onclick = function() {
      loadProviderPanel();
    };

    document.getElementById('btn-provider-sectors-refresh').onclick = function() {
      loadProviderSectors(true).then(loadProviderContracts);
    };

    document.getElementById('btn-provider-sector-create').onclick = async function() {
      const msgEl = document.getElementById('provider-sector-msg');
      const sectorName = (document.getElementById('provider-sector-name').value || '').trim();
      const organizationName = (document.getElementById('provider-sector-org').value || '').trim();
      const computeDomain = (document.getElementById('provider-sector-domain').value || '').trim();
      const description = (document.getElementById('provider-sector-description').value || '').trim();
      if (!sectorName) { setInlineMsg(msgEl, 'err', 'Укажите название сектора.'); return; }
      this.disabled = true;
      try {
        const sector = await providerApi('/provider/sectors', {
          method: 'POST',
          payload: {
            sector_name: sectorName,
            organization_name: organizationName,
            compute_domain: computeDomain,
            description
          }
        });
        setInlineMsg(msgEl, 'ok', 'Сектор создан: ' + (sector.sector_name || sector.sector_id));
        document.getElementById('provider-sector-name').value = '';
        document.getElementById('provider-sector-org').value = '';
        document.getElementById('provider-sector-domain').value = '';
        document.getElementById('provider-sector-description').value = '';
        await loadProviderSectors();
        const select = document.getElementById('provider-sector-select');
        if (select && sector && sector.sector_id) select.value = sector.sector_id;
        await loadProviderContracts();
      } catch (e) {
        setInlineMsg(msgEl, 'err', 'Ошибка создания сектора: ' + e.message);
      } finally {
        this.disabled = false;
      }
    };

    document.getElementById('provider-sector-select').onchange = function() {
      refreshProviderCreateVisibility();
      loadProviderContracts();
    };

    document.getElementById('btn-provider-create').onclick = async function() {
      const msgEl = document.getElementById('provider-create-msg');
      const sectorId = getSelectedSectorId();
      const taskName = (document.getElementById('provider-task-name').value || '').trim();
      const selectedCategory = document.getElementById('provider-computation-type').value;
      const preset = PROVIDER_CATEGORY_PRESETS[selectedCategory] || PROVIDER_CATEGORY_PRESETS.data_analysis;
      const taskCategory = (document.getElementById('provider-task-category').value || '').trim() || preset.label;
      const taskDescription = (document.getElementById('provider-task-description').value || '').trim();
      const computationType = preset.computationType;
      const workUnits = parseInt(document.getElementById('provider-work-units').value, 10);
      const reward = parseInt(document.getElementById('provider-reward').value, 10);
      const budgetCurrency = document.getElementById('provider-budget-currency').value;
      const targetRaw = parseInt(document.getElementById('provider-target').value, 10);
      const difficultyRaw = parseInt(document.getElementById('provider-difficulty').value, 10);
      const budgetRaw = parseInt(document.getElementById('provider-initial-budget').value, 10);
      const activateNow = !!document.getElementById('provider-activate-now').checked;

      if (!sectorId) { setInlineMsg(msgEl, 'err', 'Сначала выберите или создайте сектор.'); return; }
      if (!taskName) { setInlineMsg(msgEl, 'err', 'Укажите название задачи.'); return; }
      if (!workUnits || workUnits < 1) { setInlineMsg(msgEl, 'err', 'Ед. на сдачу должны быть >= 1.'); return; }
      if (!reward || reward < 1) { setInlineMsg(msgEl, 'err', 'Награда должна быть >= 1.'); return; }

      const targetTotal = targetRaw && targetRaw >= workUnits ? targetRaw : (workUnits * 10);
      const difficulty = difficultyRaw && difficultyRaw > 0
        ? difficultyRaw
        : (preset.defaultDifficulty || DEFAULT_DIFFICULTY_BY_COMPUTATION[computationType] || 3);
      const jobsEstimate = Math.max(1, Math.floor(targetTotal / Math.max(1, workUnits)));
      const initialBudget = Number.isFinite(budgetRaw) ? Math.max(0, budgetRaw) : (reward * jobsEstimate);

      const payload = {
        sector_id: sectorId,
        task_name: taskName,
        task_description: taskDescription,
        task_category: taskCategory,
        computation_type: computationType,
        work_units_required: workUnits,
        reward_per_task: reward,
        budget_currency: budgetCurrency,
        target_total_work_units: targetTotal,
        difficulty,
        initial_budget_tokens: initialBudget,
        activate_now: activateNow
      };

      this.disabled = true;
      setInlineMsg(msgEl, 'info', 'Создание контракта...');
      try {
        const response = await providerApi('/provider/contracts', { method: 'POST', payload });
        const created = response.contract || response;
        const wallet = response.wallet || null;
        const walletHint = wallet ? ' · кошелёк: ' + formatWalletBalances(wallet.balances) : '';
        setInlineMsg(msgEl, 'ok', 'Контракт создан: ' + (created.contract_id || '') + walletHint);
        document.getElementById('provider-task-name').value = '';
        document.getElementById('provider-task-description').value = '';
        document.getElementById('provider-target').value = '';
        document.getElementById('provider-initial-budget').value = '';
        await loadProviderContracts();
        loadContracts();
      } catch (e) {
        setInlineMsg(msgEl, 'err', 'Ошибка создания: ' + e.message);
      } finally {
        this.disabled = false;
      }
    };

    function loadContracts() {
      const load = document.getElementById('contracts-load');
      const table = document.getElementById('table-contracts');
      api('/contracts')
        .then(list => {
          load.style.display = 'none';
          const tbody = table.querySelector('tbody');
          tbody.innerHTML = '';
          const key = getApiKey();
          (list || []).forEach(c => {
            const tr = document.createElement('tr');
            const category = c.task_category || '';
            const name = c.task_name || c.contract_id || '';
            const desc = c.task_description || '';
            const pct = c.completion_pct != null ? c.completion_pct : '-';
            const active = c.active_workers != null ? c.active_workers : '-';
            const freeVol = (c.remaining_volume != null ? c.remaining_volume : c.free_volume) ?? (c.work_units_required ?? '-');
            const reward = c.reward_per_task != null ? c.reward_per_task : (c.reward ?? '-');
            const rewardCurrency = c.reward_currency || c.budget_currency || 'RUB';
            const takeBtn = key
              ? '<button type="button" class="primary btn-take-task" data-contract-id="' + (c.contract_id || '') + '" data-sector-id="' + (c.sector_id || '') + '">Взять в работу (через ПО)</button>'
              : '<span class="muted">Войдите</span>';
            tr.innerHTML =
              '<td><strong>' + (name || '') + '</strong><br><small style="color:#888;">' + (c.contract_id || '') + '</small></td>' +
              '<td>' + (category || '-') + '</td>' +
              '<td>' + (desc || '-') + '</td>' +
              '<td>' + (c.work_units_required ?? '-') + '</td>' +
              '<td><span class="progress-pct">' + pct + '%</span></td>' +
              '<td>' + active + '</td>' +
              '<td>' + freeVol + '</td>' +
              '<td><strong>' + reward + ' ' + rewardCurrency + '</strong></td>' +
              '<td>' + takeBtn + '</td>';
            tbody.appendChild(tr);
            const btn = tr.querySelector('.btn-take-task');
            if (btn) {
              btn.onclick = async () => {
                const apiKey = getApiKey();
                if (!apiKey) { alert('Выберите вычислителя или введите API-ключ.'); return; }
                const sectorPart = c.sector_name ? ('Сектор: ' + c.sector_name + '. ') : '';
                alert(
                  sectorPart +
                  'Для старта вычислений скачайте Desktop Agent, затем выберите сектор/контракт. Рекомендуемый режим: adaptive.'
                );
                window.location.href = '/download/desktop-agent';
              };
            }
          });
          table.style.display = (list && list.length) ? 'table' : 'none';
        })
        .catch(() => { load.textContent = 'Ошибка загрузки'; });
    }

    function loadTasks() {
      const load = document.getElementById('tasks-load');
      const empty = document.getElementById('tasks-empty');
      const table = document.getElementById('table-tasks');
      api('/chain')
        .then(chain => {
          load.style.display = 'none';
          const rows = [];
          (chain || []).slice(-100).forEach(block => {
            (block.transactions || []).forEach(tx => {
              if (tx.type === 'work_receipt')
                rows.push({ block: block.index, client: (tx.client_id || '').slice(0, 8) + '…', contract: tx.contract_id || '', units: tx.work_units ?? '' });
            });
          });
          rows.reverse();
          const tbody = table.querySelector('tbody');
          tbody.innerHTML = '';
          rows.slice(0, 100).forEach(r => {
            const tr = document.createElement('tr');
            tr.innerHTML = '<td>' + r.block + '</td><td class="mono">' + r.client + '</td><td>' + r.contract + '</td><td>' + r.units + '</td>';
            tbody.appendChild(tr);
          });
          table.style.display = rows.length ? 'table' : 'none';
          empty.style.display = rows.length ? 'none' : 'block';
        })
        .catch(() => { load.textContent = 'Ошибка загрузки'; });
    }

    function loadChain() {
      const load = document.getElementById('chain-load');
      const lastIndexEl = document.getElementById('chain-last-index');
      const lastTxCountEl = document.getElementById('chain-last-tx-count');
      const lastTsEl = document.getElementById('chain-last-ts');
      api('/chain')
        .then(chain => {
          load.style.display = 'none';
          const rows = Array.isArray(chain) ? chain : [];
          const last = rows.length ? rows[rows.length - 1] : null;
          if (!last) {
            if (lastIndexEl) lastIndexEl.textContent = '-';
            if (lastTxCountEl) lastTxCountEl.textContent = '-';
            if (lastTsEl) lastTsEl.textContent = '-';
            return;
          }
          const ts = last.timestamp ? new Date(last.timestamp * 1000).toLocaleString() : '-';
          if (lastIndexEl) lastIndexEl.textContent = String(last.index ?? '-');
          if (lastTxCountEl) lastTxCountEl.textContent = String((last.transactions || []).length);
          if (lastTsEl) lastTsEl.textContent = ts;
        })
        .catch(() => { load.textContent = 'Ошибка загрузки'; });
    }

    function loadStats() {
      api('/metrics')
        .then(m => {
          document.getElementById('st-chain').textContent = m.chain_length ?? '-';
          document.getElementById('st-clients').textContent = m.clients_count ?? '-';
          document.getElementById('st-pending').textContent = m.pending_transactions ?? '-';
          document.getElementById('st-requests').textContent = JSON.stringify(m.request_counts || {}, null, 2);
          document.getElementById('st-errors').textContent = JSON.stringify(m.error_counts || {}, null, 2);
        })
        .catch(() => {
          document.getElementById('st-requests').textContent = 'Ошибка загрузки';
        });
    }

    let profileData = null;
    let profileWallet = null;

    function applyWalletToProfile(walletInfo) {
      const balances = walletInfo?.balances || {};
      profileWallet = balances;
      const walletEl = document.getElementById('profile-fiat-wallet');
      if (walletEl) walletEl.textContent = formatWalletBalances(balances);
    }

    async function loadProfileJobs() {
      const key = getApiKey();
      const table = document.getElementById('table-profile-jobs');
      const emptyEl = document.getElementById('profile-jobs-empty');
      if (!key || !table || !emptyEl) return;
      try {
        const r = await fetch(base + '/jobs/my?limit=50', { headers: { 'Authorization': 'Bearer ' + key } });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const payload = await r.json();
        const list = payload.jobs || [];
        const tbody = table.querySelector('tbody');
        tbody.innerHTML = '';
        list.forEach((job) => {
          const tr = document.createElement('tr');
          const updatedAt = job.updated_at ? new Date(job.updated_at * 1000).toLocaleString() : '-';
          tr.innerHTML =
            '<td class="mono">' + (job.job_id || '-') + '</td>' +
            '<td>' + (job.contract_id || '-') + '</td>' +
            '<td>' + (job.status || '-') + '</td>' +
            '<td>' + (job.scheduler_profile_effective || job.scheduler_profile_requested || '-') + '</td>' +
            '<td>' + (job.reassign_count ?? 0) + '</td>' +
            '<td>' + updatedAt + '</td>';
          tbody.appendChild(tr);
        });
        table.style.display = list.length ? 'table' : 'none';
        emptyEl.style.display = list.length ? 'none' : 'block';
        if (!list.length) emptyEl.textContent = 'Заданий пока нет.';
      } catch (e) {
        table.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Ошибка загрузки заданий: ' + e.message;
      }
    }

    async function loadProfileDevices() {
      const key = getApiKey();
      const table = document.getElementById('table-profile-devices');
      const emptyEl = document.getElementById('profile-devices-empty');
      if (!key || !table || !emptyEl) return;
      try {
        const r = await fetch(base + '/agent/devices/my', { headers: { 'Authorization': 'Bearer ' + key } });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const payload = await r.json();
        const list = payload.devices || [];
        const tbody = table.querySelector('tbody');
        tbody.innerHTML = '';
        list.forEach((device) => {
          const tr = document.createElement('tr');
          const lastSeen = device.last_seen_at ? new Date(device.last_seen_at * 1000).toLocaleString() : '-';
          const toggleLabel = device.is_disabled ? 'Включить' : 'Отключить';
          tr.innerHTML =
            '<td class="mono">' + (device.device_id || '-') + '</td>' +
            '<td>' + (device.device_name || '-') + '</td>' +
            '<td>' + (device.agent_version || '-') + '</td>' +
            '<td>' + (device.status || '-') + (device.is_disabled ? ' (disabled)' : '') + '</td>' +
            '<td>' + (device.status_reason || '-') + '</td>' +
            '<td>' + lastSeen + '</td>' +
            '<td><button type="button" data-device-toggle>' + toggleLabel + '</button></td>';
          tbody.appendChild(tr);
          const btn = tr.querySelector('[data-device-toggle]');
          if (btn) {
            btn.onclick = async () => {
              try {
                const res = await fetch(base + '/agent/devices/' + encodeURIComponent(device.device_id) + '/disable', {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + key,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ is_disabled: !device.is_disabled })
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
                await loadProfileDevices();
              } catch (e) {
                alert('Ошибка управления устройством: ' + e.message);
              }
            };
          }
        });
        table.style.display = list.length ? 'table' : 'none';
        emptyEl.style.display = list.length ? 'none' : 'block';
        if (!list.length) emptyEl.textContent = 'Устройств пока нет.';
      } catch (e) {
        table.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Ошибка загрузки устройств: ' + e.message;
      }
    }

    function loadProfile() {
      const key = getApiKey();
      const loginRequired = document.getElementById('profile-login-required');
      const content = document.getElementById('profile-content');
      const msg = document.getElementById('profile-withdraw-msg');
      msg.style.display = 'none';
      if (!key) {
        loginRequired.style.display = 'block';
        content.style.display = 'none';
        return;
      }
      loginRequired.style.display = 'none';
      content.style.display = 'block';
      fetch(base + '/me', { headers: { 'Authorization': 'Bearer ' + key } })
        .then(r => {
          if (!r.ok) throw new Error('Неверный API-ключ');
          return r.json();
        })
        .then(d => {
          profileData = d;
          document.getElementById('profile-nickname-full').textContent = d.nickname || d.login || d.client_id?.slice(0, 8) + '…' || '-';
          document.getElementById('profile-login-full').textContent = d.login || '-';
          document.getElementById('profile-client-id').textContent = d.client_id || '-';
          document.getElementById('profile-client-id').title = d.client_id || '';
          document.getElementById('profile-balance-full').textContent = d.balance ?? 0;
          document.getElementById('profile-submissions-full').textContent = d.submissions_count ?? 0;
          applyWalletToProfile({ balances: d.fiat_wallet || {} });
          return fetch(base + '/market/wallet', { headers: { 'Authorization': 'Bearer ' + key } });
        })
        .then(r => {
          if (!r) return null;
          if (!r.ok) throw new Error('Не удалось загрузить fiat-кошелёк');
          return r.json();
        })
        .then(wallet => {
          if (wallet) applyWalletToProfile(wallet);
          return Promise.all([loadProfileJobs(), loadProfileDevices()]);
        })
        .catch(() => {
          loginRequired.style.display = 'block';
          content.style.display = 'none';
        });
    }

    document.getElementById('btn-profile-topup').onclick = async function() {
      const msgEl = document.getElementById('profile-withdraw-msg');
      const currency = document.getElementById('profile-topup-currency').value;
      const amount = parseInt(document.getElementById('profile-topup-amount').value, 10);
      msgEl.style.display = 'none';
      if (!amount || amount < 1) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Укажите сумму пополнения (>= 1).';
        msgEl.style.display = 'block';
        return;
      }
      try {
        const res = await marketApi('/market/wallet/topup', {
          method: 'POST',
          payload: { currency, amount, source: 'manual_dashboard_topup' }
        });
        applyWalletToProfile(res.wallet || {});
        document.getElementById('profile-topup-amount').value = '';
        msgEl.className = 'msg ok';
        msgEl.textContent = 'Кошелёк пополнен: +' + amount + ' ' + currency;
        msgEl.style.display = 'block';
      } catch (e) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Ошибка пополнения: ' + e.message;
        msgEl.style.display = 'block';
      }
    };

    document.getElementById('btn-profile-convert').onclick = async function() {
      const msgEl = document.getElementById('profile-withdraw-msg');
      const fromCurrency = document.getElementById('profile-convert-from').value;
      const toCurrency = document.getElementById('profile-convert-to').value;
      const amount = parseInt(document.getElementById('profile-convert-amount').value, 10);
      msgEl.style.display = 'none';
      if (!amount || amount < 1) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Укажите сумму конвертации (>= 1).';
        msgEl.style.display = 'block';
        return;
      }
      if (fromCurrency === toCurrency) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Выберите разные валюты для конвертации.';
        msgEl.style.display = 'block';
        return;
      }
      try {
        const conversion = await marketApi('/market/convert', {
          method: 'POST',
          payload: { from_currency: fromCurrency, to_currency: toCurrency, amount }
        });
        applyWalletToProfile({ balances: conversion.balances || {} });
        document.getElementById('profile-convert-amount').value = '';
        msgEl.className = 'msg ok';
        msgEl.textContent = 'Конвертация выполнена: ' + conversion.source_amount + ' ' + conversion.from_currency + ' -> ' + conversion.target_amount + ' ' + conversion.to_currency;
        msgEl.style.display = 'block';
      } catch (e) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Ошибка конвертации: ' + e.message;
        msgEl.style.display = 'block';
      }
    };

    document.getElementById('btn-profile-withdraw').onclick = function() {
      const key = getApiKey();
      const msgEl = document.getElementById('profile-withdraw-msg');
      msgEl.style.display = 'none';
      if (!key || !profileData) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Загрузите профиль (откройте вкладку ещё раз).';
        msgEl.style.display = 'block';
        return;
      }
      const currency = document.getElementById('profile-withdraw-currency').value;
      const amount = parseInt(document.getElementById('profile-withdraw-amount').value, 10);
      const card = (document.getElementById('profile-withdraw-card').value || '').replace(/\s/g, '');
      if (!amount || amount < 1) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Укажите сумму для вывода (не менее 1).';
        msgEl.style.display = 'block';
        return;
      }
      const available = (profileWallet && typeof profileWallet[currency] === 'number') ? profileWallet[currency] : 0;
      if (amount > available) {
        msgEl.className = 'msg err';
        msgEl.textContent = 'Недостаточно средств в валюте ' + currency + '.';
        msgEl.style.display = 'block';
        return;
      }
      // Валидация номера карты: только цифры, длина 12-19 символов
      const cardDigits = card.replace(/\s/g, '');
      if (!/^\d{12,19}$/.test(cardDigits)) {
        msgEl.className = 'msg err';
        msgEl.textContent = '❌ Неверный формат номера карты. Введите 12-19 цифр (например: 1234567890123456).';
        msgEl.style.display = 'block';
        return;
      }
      marketApi('/market/withdrawals', {
        method: 'POST',
        payload: {
          currency: currency,
          amount: amount,
          card_number: cardDigits
        }
      })
        .then(resp => {
          applyWalletToProfile(resp.wallet || {});
          msgEl.className = 'msg ok';
          msgEl.textContent = 'Заявка на вывод создана: ' + amount + ' ' + currency + ' на карту ****' + card.slice(-4) + '. Статус: queued.';
          msgEl.style.display = 'block';
          document.getElementById('profile-withdraw-amount').value = '';
          document.getElementById('profile-withdraw-card').value = '';
        })
        .catch(e => {
          msgEl.className = 'msg err';
          msgEl.textContent = 'Ошибка вывода: ' + e.message;
          msgEl.style.display = 'block';
        });
    };

    document.getElementById('btn-profile-jobs-refresh').onclick = function() {
      loadProfileJobs();
    };

    document.getElementById('btn-profile-devices-refresh').onclick = function() {
      loadProfileDevices();
    };

    // Инициализация при загрузке страницы
    loadOverview();
  </script>
</body>
</html>
