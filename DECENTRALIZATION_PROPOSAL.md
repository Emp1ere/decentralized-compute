# Предложение по переходу к децентрализованному созданию блоков

Документ описывает **предлагаемые изменения архитектуры** для перехода к децентрализованному созданию блоков с профилактикой выявленных ошибок и сложностей для пользователя. Реализацию не выполнять — только план.

---

## 1. Целевая модель

- **Оба узла** могут принимать `submit_work` и создавать блоки (или только лидер создаёт блоки, но лидер ротируется).
- **Пользователь** не теряет награды при форках и видит предсказуемое состояние (баланс, статус «в блоке» / «ожидает»).
- **Транзакции** не теряются при замене цепочки; при проигравшем блоке есть явный путь: повторная отправка или автоматическое возвращение в pending.

---

## 2. Выбор стратегии создания блоков

Рекомендуется выбрать **одну** из двух стратегий (или гибрид с явными правилами).

### Вариант A: «Только лидер создаёт блоки»

- Определение лидера: `get_current_leader()` по хешу последнего блока (уже есть).
- Любой узел может принимать `submit_work`. Если узел **не лидер**: не вызывает `mine_pending_transactions`, а отправляет пару (reward_tx, work_receipt_tx) на **URL лидера** (внутренний API или `add_pending_tx`), ждёт ответа и при успехе опционально ждёт появления блока (poll `/chain` или callback).
- Лидер добавляет транзакции в pending и создаёт блок при следующем submit или по таймеру (если ввести «майнинг по таймеру при непустом pending»).
- **Плюсы:** меньше форков, один источник блоков. **Минусы:** лидер — единая точка отказа и узкое место; при недоступности лидера нужен fallback (см. ниже).

### Вариант B: «Оба узла могут создавать блоки»

- Трафик распределён (nginx round-robin или ip_hash по части эндпоинтов): `submit_work` и/или `get_task` попадают на оба узла.
- Узел, принявший `submit_work`, верифицирует работу, добавляет reward + work_receipt в pending, синхронизирует pending с пиром, создаёт блок.
- Возможны одновременные блоки → форки. Консенсус по текущему правилу (longest valid chain, затем timestamp/hash).
- **Плюсы:** нет единой точки отказа. **Минусы:** нужна аккуратная обработка форков и «потерянных» tx (см. раздел 4).

### Вариант C: Гибрид

- По умолчанию «submit к лидеру» (как в A). Если лидер недоступен по таймауту (например 5–10 с): узел сам добавляет tx в свой pending и создаёт блок (как в B). Так децентрализация сохраняется при отказе лидера, но в норме форков меньше.

---

## 3. Изменения в маршрутизации (nginx / конфиг)

- Перевести часть трафика с `node1_only` на общий upstream (оба узла):
  - Для **варианта A/C:** на лидера можно проксировать только внутренние вызовы; внешние `submit_work` можно оставить на оба узла (каждый решает, сам майнить или слать лидеру).
  - Для **варианта B:** в общий upstream отдать минимум `submit_work` и, при желании, `get_task`, чтобы оба узла получали нагрузку.
- Сохранить в `node1_only` только те эндпоинты, которые по продуктовым причинам должны идти на один узел (если такие останутся), либо убрать `node1_only` и везде использовать общий upstream.
- Воркеры из дашборда: либо оставить один URL (тогда трафик идёт через nginx и распределяется), либо задавать разным воркерам разные `ORCHESTRATOR_URL` (node_1 и node_2) для явного распределения.

---

## 4. Профилактика потери транзакций при замене цепочки

**Проблема:** В `replace_chain_from_peer()` выполняется `pending_transactions = []`, из‑за чего транзакции, не попавшие в выигравшую цепочку, теряются.

**Предлагаемые изменения (архитектура):**

1. **Перед заменой цепочки** построить множество идентификаторов транзакций, уже входящих в новую цепочку. Идентификатор пары reward+work_receipt: например `(client_id, contract_id, result_data)` для work_receipt (уже уникален по смыслу).
2. **Локальные pending:** для каждой транзакции в текущем `pending_transactions` проверить, есть ли она (или соответствующая пара) в новой цепочке.
3. **Оставшиеся транзакции** (не попали в выигравшую цепочку):
   - **Вариант 4a:** Вернуть их в `pending_transactions` после замены цепочки (и пересчёта балансов). Следующий майнинг упакует их. Риск: дубликат, если та же tx уже в цепочке под другим блоком — нужна проверка «нет в chain» перед повторным добавлением.
   - **Вариант 4b:** Не возвращать в pending, а складывать в отдельную структуру «orphaned_pending» и отдавать через отдельный эндпоинт (например `GET /orphaned_tx?client_id=...`) или включать в ответ следующего `get_balance` поле `pending_reward: [...]`. Клиент/воркер при наличии таких записей повторяет submit (идемпотентность по proof уже есть: повторная сдача того же proof вернёт 200 «already processed» и не создаст двойной награды).
4. В **blockchain** при замене цепочки не просто обнулять pending, а вызывать новую функцию типа `_reconcile_pending_after_chain_replace(new_chain_tx_ids)` и по её результату либо оставлять в pending только «не попавшие» tx, либо сохранять их в orphaned и очищать pending.

Дополнительно: при создании блока после форка можно логировать «our block orphaned, re-queuing N tx» для метрик и отладки.

---

## 5. Согласованность лидера и синхронизация перед решением

**Проблема:** До синхронизации узлы могут по-разному определять лидера.

**Предложение:**

- Перед тем как принять submit и решить «мы лидер / не лидер», узел вызывает **sync_chain_from_peer()** (или уже синхронизирован по таймеру с коротким интервалом, например 5–10 с). Тогда оба узла видят одну и ту же «последнюю» цепочку и одного лидера.
- В эндпоинте `submit_work`: в начале обработки (после аутентификации и проверки proof) один раз получить актуальную цепочку с пира, затем вычислить лидера. Если «мы не лидер» — отправить tx на лидера; если «мы лидер» — выполнять текущую логику (добавление в pending, sync pending, майнинг).
- Опционально: вынести «получить лидера» в отдельный внутренний метод с принудительной синхронизацией цепочки, чтобы не дублировать вызовы.

---

## 6. Поведение для пользователя (UX и API)

- **Ответ submit_work:** В теле ответа добавить поле, например `in_block: true | false`. Если блок создан на этом же запросе — `in_block: true`. Если tx отправлены лидеру и приняты — `in_block: false`, `message: "Reward will be applied when included in a block"`. Так пользователь не считает 200 гарантией немедленного обновления баланса.
- **get_balance:** Опционально возвращать `chain_tip_index` или `last_sync_time`, чтобы клиент мог показать «данные обновлены по блок N» или «подождите синхронизации». Либо перед ответом вызывать быструю синхронизацию с пиром и отдавать уже актуальный баланс.
- **Дашборд:** После нажатия «Сдать работу» показывать: «Награда ожидает включения в блок» при `in_block: false`; при следующей загрузке или при опросе баланса обновлять состояние. При ошибке «награда не найдена в цепочке» (если позже ввести эндпоинт проверки) — кнопка «Повторить отправку» или автоматический retry воркера.
- **Воркер:** При ответе 503 или таймауте при submit — повтор с экспоненциальной задержкой (например 2, 4, 8 с), максимум 3 попытки. Не считать 200 с `in_block: false` ошибкой; считать успехом и логировать «reward queued».

---

## 7. Обработка недоступности лидера (варианты A и C)

- **Таймаут запроса к лидеру:** например 10 с. При истечении: не возвращать 500, а перейти в режим «создать блок здесь» (как в варианте B): добавить tx в локальный pending, sync_pending_from_peer(), mine_pending_transactions(), отправить блок пиру. Вернуть клиенту 200 с `in_block: true` и пояснением в логе, что лидер был недоступен.
- **Повтор при 5xx от лидера:** одна-две повторные попытки с короткой паузой; при повторном сбое — тот же fallback «создать блок здесь».
- В **варианте C** это поведение заложить по умолчанию: сначала попытка к лидеру, при неудаче — локальное создание блока.

---

## 8. Метрики и мониторинг

- **В блок:** добавить поле `creator_node_id` (или `node_id`) — идентификатор узла (например из env `NODE_ID` или hostname). При замене цепочки и отбрасывании локального блока увеличивать счётчик `blocks_orphaned_total` (по узлу).
- **В /metrics:** выдавать: количество блоков в цепочке по `creator_node_id`; количество замен цепочки за период; размер pending и количество «re-queued» tx после замены (если реализован вариант 4a).
- Это позволит проверять, что блоки создаются обоими узлами, и отслеживать частоту форков и потерь.

---

## 9. Порядок внедрения (рекомендуемый)

1. **Блокчейн и pending:** реализовать сохранение/возврат «не попавших» tx при замене цепочки (раздел 4) и тесты на форк + замену цепочки.
2. **Лидер и синхронизация:** перед решением «кто майнит» вызывать синхронизацию цепочки (раздел 5).
3. **submit_work:** ввести логику «если не лидер — отправить на лидера; при таймауте/ошибке — майнить локально» (вариант A или C). Добавить в ответ поле `in_block`.
4. **Маршрутизация:** перевести часть трафика на оба узла (раздел 3).
5. **Клиент и дашборд:** retry при 5xx, отображение «ожидает включения в блок» (раздел 6).
6. **Метрики:** creator_node_id в блоке, счётчики в /metrics (раздел 8).

Так риски потери наград и несогласованности лидера снижаются до внедрения распределённого трафика.

---

## 10. Краткая сводка по профилактике

| Сложность | Предлагаемая профилактика |
|-----------|---------------------------|
| Потеря tx при замене цепочки | Вычислить tx, не попавшие в новую цепочку; вернуть в pending (4a) или отдать клиенту для повтора (4b). |
| Разный лидер на узлах | Синхронизация цепочки перед определением лидера в submit_work. |
| «Награда не пришла» для пользователя | Поле `in_block` в ответе; сообщения «ожидает включения в блок»; возможность повтора submit при orphaned. |
| Задержка обновления баланса | Опционально: синхронизация перед get_balance или поле chain_tip в ответе для UI. |
| Недоступность лидера | Таймаут + fallback «создать блок здесь»; retry при 5xx. |
| Непрозрачность форков | Поле creator_node_id в блоке; метрики orphaned_blocks, replaced_chain. |

Документ можно использовать как техническое задание для реализации перехода к децентрализованному созданию блоков без изменения кода в рамках этого задания.
