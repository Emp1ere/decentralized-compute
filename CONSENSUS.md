# Консенсус в распределённой системе узлов

Описание текущего консенсуса и целевой архитектуры DSCM v2.

---

## 0. Целевая архитектура (DSCM v2)

**Два уровня консенсуса:**

1. **Raft** — ordering service Hyperledger Fabric (ordering узлов)
2. **PoUW** — верифицированная полезная работа (submit_work + contract.verify)

**Текущий MVP:** Python-блокчейн с правилом «longest valid chain» (см. ниже). Миграция на Fabric — Phase 1.

---

## 1. Тип консенсуса (текущий MVP)

**Правило выбора цепочки: «longest valid chain» (наиболее длинная валидная цепочка).**

- Узлы хранят локальную копию цепочки блоков.
- При получении цепочки от пира локальная цепочка **заменяется** на цепочку пира **только если** цепочка пира **валидна** и **не короче** локальной.
- При одинаковой длине (форк) используется детерминированное правило разрешения форка (см. ниже).

**Создание блоков:** по модели **Proof-of-Useful-Work (PoUW)** — блок создаётся при верифицированной полезной работе (submit_work + contract.verify), а не по перебору nonce. Хеш блока используется только для целостности (difficulty=0).

---

## 2. Где реализован консенсус

| Место в коде | Назначение |
|--------------|------------|
| `blockchain.replace_chain_from_peer(chain_list)` | Основная точка консенсуса: замена локальной цепочки на цепочку пира по правилу «longest valid chain» + разрешение форка. |
| `blockchain.add_block_from_peer(block_dict)` | Приём **одного** блока от пира: проверка, что блок — следующий по индексу и по previous_hash; идемпотентность при уже известном блоке. |
| `app.sync_chain_from_peer()` | Периодически и при старте запрашивает у пира GET /chain и вызывает `replace_chain_from_peer`. |
| `app.receive_block()` | Принимает POST /receive_block, вызывает `add_block_from_peer`; при успехе пересылает блок дальше по PEER_URL. |
| `app.receive_chain()` | Принимает POST /receive_chain (полная цепочка), вызывает `replace_chain_from_peer`. |

---

## 3. Валидация цепочки и блока

### 3.1. Проверки в `replace_chain_from_peer(chain_list)`

1. **Цепочка не пустая.**
2. **Genesis-блок:** `index == 0`, `previous_hash == "0"`.
3. **Для каждого блока по порядку:**
   - `block_dict["index"] == i` (последовательные индексы);
   - `previous_hash` совпадает с хешем предыдущего блока в новой цепочке;
   - объект `Block` строится из полей пира; пересчитанный `block.hash` совпадает с `block_dict["hash"]`.
4. **Все reward-транзакции** во всех блоках проходят `_is_valid_reward_tx` (type, to, amount >= 0).

Если любая проверка не прошла — цепочка отклоняется, возвращается `False` и сообщение об ошибке.

### 3.2. Правило «longest valid chain» и форк

- Если **длина цепочки пира меньше** длины локальной → замена **не выполняется** (`"chain not longer"`).
- Если **длина равна** (форк — два разных последних блока при одной длине):
  - Сравниваются **timestamp** последних блоков: выбирается цепочка с **меньшим** timestamp (блок создан раньше).
  - При **равном** timestamp сравниваются **хеши** последних блоков: выбирается цепочка с **лексикографически меньшим** хешем.
  - Если по этим правилам выигрывает цепочка пира — локальная цепочка заменяется; иначе остаётся локальная (`"fork resolved in favor of local chain"`).
- Если **длина цепочки пира больше** — после проверки валидности всех блоков локальная цепочка заменяется на цепочку пира.

После любой замены цепочки:
- `pending_transactions` обнуляется;
- балансы пересчитываются заново по всем транзакциям новой цепочки;
- цепочка сохраняется на диск.

### 3.3. Проверки в `add_block_from_peer(block_dict)`

- Если блок уже есть (индекс меньше длины цепочки или тот же блок в конце) → идемпотентный успех.
- Блок должен быть **следующим**: `block_dict["index"] == len(self.chain)`.
- `block_dict["previous_hash"]` должен совпадать с хешем последнего блока.
- Пересчитанный хеш блока совпадает с переданным.
- Все reward-транзакции в блоке валидны.

При успехе блок добавляется в цепочку, транзакции применяются к балансам, цепочка сохраняется на диск.

---

## 4. Как консенсус задействуется в работе системы

### 4.1. При старте узла

- `startup_sync()`: пауза 3 с, затем один раз вызывается `sync_chain_from_peer()` — у пира запрашивается GET /chain, выполняется `replace_chain_from_peer`. Узел подстраивается под текущую длину и содержание цепочки пира.

### 4.2. Периодическая синхронизация

- `periodic_sync()` в фоновом потоке: каждые `SYNC_INTERVAL` секунд (по умолчанию 30) вызывается `sync_chain_from_peer()`. Узлы постоянно приводят цепочку к «longest valid chain».

### 4.3. После создания блока (submit_work)

- Узел создаёт блок и отправляет его пиру: POST /receive_block с телом блока.
- Пир вызывает `add_block_from_peer`: если блок следующий по индексу и валидный — добавляет в цепочку.
- Если пир отклонил блок (например, у пира уже другая цепочка), инициатор может вызвать `sync_chain_from_peer()` и подтянуть цепочку пира (как в коде при `peer_rejected_block`).

### 4.4. Пересылка блока по цепочке узлов

- После успешного `add_block_from_peer` узел пересылает тот же блок своему пиру (POST /receive_block на PEER_URL). Так блок может распространяться на несколько узлов (при топологии цепочки).

### 4.5. Синхронизация pending перед созданием блока

- Перед вызовом `mine_pending_transactions()` в submit_work вызывается `sync_pending_from_peer()`: у пира запрашивается GET /pending, транзакции объединяются с локальными (с учётом дубликатов по result_data). Это не консенсус по цепочке, но согласование состояния «очередь транзакций» между узлами перед майнингом.

---

## 5. Определение лидера (не часть консенсуса по цепочке)

- **Функция** `get_current_leader()`: лидер определяется **детерминированно** по хешу последнего блока в локальной цепочке:
  - `hash_int = int(last_block_hash[:8], 16)`
  - `leader_index = hash_int % len(NODE_IDS)`
  - возвращается `NODE_IDS[leader_index]`.

- **Использование:** в текущем коде лидер используется только в **метриках** (`/metrics`: `current_leader`, `is_leader`). В логике **submit_work** лидер **не используется** — блок создаёт тот узел, который принял submit_work.

После синхронизации цепочки оба узла видят один и тот же последний блок → оба вычисляют одного и того же лидера. Это согласованное «состояние лидера», но не часть правил принятия цепочки.

---

## 6. Краткая схема работы консенсуса

```
Узел A                          Узел B
   |                                |
   |  GET /chain                    |
   |------------------------------>|
   |  peer_chain                    |
   |<------------------------------|
   |  replace_chain_from_peer()     |
   |  (если цепочка B длиннее и     |
   |   валидна — заменить свою)     |
   |                                |
   |  (при submit_work на A:        |
   |   создать блок,               |
   |   POST /receive_block -----------> add_block_from_peer()
   |   на B)                        |  (если блок следующий — добавить)
   |                                |  переслать блок дальше по PEER_URL
   |  periodic_sync каждые 30 с:    |
   |  GET /chain -> replace_chain   |
```

---

## 7. Итог

| Элемент | Реализация |
|--------|------------|
| Правило выбора цепочки | Longest valid chain; при равной длине — по timestamp, затем по hash последнего блока. |
| Валидация | Genesis, последовательность индексов и previous_hash, совпадение хешей блоков, валидность reward-транзакций. |
| Точки применения | replace_chain_from_peer (периодически и при старте, receive_chain); add_block_from_peer (receive_block). |
| Согласование состояния | Периодический sync_chain; sync_pending перед майнингом; пересылка блока после приёма. |
| Лидер | Детерминированно по хешу последнего блока; используется только в метриках, не в submit_work. |

Консенсус реализован и используется в описанных точках; выбор цепочки и разрешение форков работают по правилу «longest valid chain» с однозначным разрешением форка по timestamp и hash.
