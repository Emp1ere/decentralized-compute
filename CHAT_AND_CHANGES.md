# Сохранение чата и внесённых изменений

Документ создан по запросу: сохранить всё, что было сделано в чате, вместе с описанием изменений.

---

## 1. Содержание чата (кратко)

### Вопрос: роль файла `orchestrator_node/requirements.txt`
**Ответ:** Файл задаёт зависимости Python для узла-оркестратора: **Flask** (веб-API) и **requests** (HTTP к пирам/воркерам). Используется в Dockerfile при сборке образа и локально при `pip install -r requirements.txt`.

### Вопрос: в проекте сейчас только один узел?
**Ответ:** Нет. В `docker-compose.yml` описаны 4 сервиса: два оркестратора (`orchestrator_node_1`, `orchestrator_node_2`) и два воркера (`client_worker_1`, `client_worker_2`). Код оркестратора один и тот же, запускается в двух контейнерах с разными `PEER_URL` и портами.

### Вопрос: децентрализованы?
**Ответ:** Частично. Уже было: два равноправных оркестратора, синхронизация блоков (кто намайнил — шлёт блок пиру), приём блока с проверкой. Не хватало: начальной синхронизации при старте, разрешения конфликтов (longest chain), периодической синхронизации.

### Запрос: добавить то, что нужно для полноценной децентрализации, с объяснением рядом с каждой строчкой кода
**Сделано:** добавлена начальная синхронизация при старте, приём полной цепочки от пира (longest valid chain), разрешение конфликтов при отклонении блока, периодическая синхронизация. В коде добавлены поясняющие комментарии.

### Запрос: сохранить всё сделанное вместе с чатом
**Сделано:** код уже сохранён в файлах; создан этот файл `CHAT_AND_CHANGES.md` с содержанием чата и списком изменений.

### Запрос: добавить настоящий консенсус вместо Proof-of-Authority
**Сделано:** консенсус заменён на **Proof-of-Work (PoW)**. Оба узла получают одни и те же pending-транзакции (POST /add_pending_tx), майнят в фоне (mining_loop); первый найденный валидный блок рассылается и принимается; при приёме блока от пира pending очищается. Рядом с каждой строкой кода добавлены пояснения; изменения и чат зафиксированы в CHAT_AND_CHANGES.md.

---

## 2. Внесённые изменения в коде

### 2.1. `orchestrator_node/blockchain.py`

**Добавлено:**

- Метод **`replace_chain_from_peer(chain_list)`**  
  Заменяет локальную цепочку на цепочку пира, если она **валидна** и **длиннее** (правило «longest valid chain»).  
  - Проверяет: не пустой список, валидный genesis (index=0, previous_hash="0").  
  - Для каждого блока: индекс, previous_hash, совпадение хеша, PoW (нули в начале хеша).  
  - Собирает новую цепочку из объектов `Block`, подменяет `self.chain`, очищает `pending_transactions`, заново считает `balances` по всем транзакциям типа `reward`.  
  - Рядом с логическими блоками добавлены комментарии (роль проверок, замена цепочки, пересчёт балансов).

### 2.2. `orchestrator_node/app.py`

**Добавлено:**

- Импорты: `threading`, `time`.
- Константа **`SYNC_INTERVAL`** (из env, по умолчанию 30 сек) — интервал периодической синхронизации.

- Функция **`sync_chain_from_peer()`**  
  Запрашивает у пира `GET /chain`, вызывает `blockchain.replace_chain_from_peer()` и при необходимости заменяет локальную цепочку. Комментарии у каждой строки (проверка PEER_URL, запрос, разбор ответа, логи).

- Функция **`startup_sync()`**  
  Ждёт 3 секунды, затем один раз вызывает `sync_chain_from_peer()`. Нужна для синхронизации при старте узла (чтобы пир успел подняться). С комментариями.

- Функция **`periodic_sync()`**  
  В цикле раз в `SYNC_INTERVAL` вызывает `sync_chain_from_peer()`. Комментарии у строк.

- Эндпоинт **`POST /receive_chain`**  
  Принимает тело как список блоков, вызывает `replace_chain_from_peer()`; возвращает accepted/error. Комментарии у строк.

- В **`submit_work`** после отправки блока пиру: если пир **отклонил** блок, вызывается `sync_chain_from_peer()` (разрешение конфликта — подтягиваем более длинную цепочку пира). Комментарий добавлен.

- В **`if __name__ == "__main__"`** перед `app.run()`:  
  - Запуск потока **`startup_sync`** (daemon).  
  - Запуск потока **`periodic_sync`** (daemon).  
  С комментариями у каждой строки.

---

## 3. Итог по децентрализации

| Что было | Что добавлено |
|---------|----------------|
| Два узла, отправка блока пиру после майнинга | Начальная синхронизация при старте (подтягивание цепочки с пира) |
| Приём одного блока через `/receive_block` | Приём полной цепочки через `replace_chain_from_peer` и `POST /receive_chain` |
| Нет выбора «чья цепочка главнее» | Правило «longest valid chain» + пересчёт балансов |
| Нет реакции на отклонение блока пиром | При отклонении блока — сразу `sync_chain_from_peer()` |
| Нет периодического выравнивания | Периодическая синхронизация раз в `SYNC_INTERVAL` |

Переменная окружения **`SYNC_INTERVAL`** (секунды) опционально задаётся в `docker-compose` или при запуске (по умолчанию 30).

---

## 4. Файлы, которые были изменены

- `orchestrator_node/blockchain.py` — добавлен метод `replace_chain_from_peer` и комментарии.
- `orchestrator_node/app.py` — добавлены `sync_chain_from_peer`, `startup_sync`, `periodic_sync`, эндпоинт `/receive_chain`, вызов синхронизации при отклонении блока пиром, запуск фоновых потоков при старте и комментарии.

Код уже сохранён в этих файлах; этот документ фиксирует содержание чата и список изменений для истории проекта.

---

## 5. Исполняемые смарт-контракты (последнее обновление)

### Запрос из чата
Сделать смарт-контракты **исполняемыми** (не JSON). Сделать их **оптимальными по «стоимости»**: только проверка выполнения работы вычислителя и вознаграждение за выполнение. Прописать, что происходит, рядом с каждой строкой кода, удалить лишнее. Зафиксировать изменения и обновить CHAT_AND_CHANGES.md.

### Что сделано

- **`orchestrator_node/contracts.py`** (новый файл)  
  Исполняемые контракты как классы Python:
  - **BaseContract**: базовый класс с `contract_id`, `work_units_required`, `reward`; методы `get_task_spec()` (минимальные данные для воркера: contract_id, work_units_required, difficulty), `verify(client_id, contract_id, work_units_done, result_data, nonce)` — проверка объёма работы и при наличии nonce пересчёт хеша и сравнение с result_data; `get_reward()`.
  - **SimpleHashPoW**: difficulty=3, work_units_required=1000, reward=10.
  - **ComplexHashPoW**: difficulty=4, work_units_required=5000, reward=50.
  - Реестр **CONTRACTS** по contract_id для быстрого доступа. Рядом с каждой логической строкой добавлены поясняющие комментарии.

- **`orchestrator_node/app.py`**  
  - Удалён список JSON-контрактов **SMART_CONTRACTS**. Подключён **CONTRACTS** из `contracts.py`.
  - **get_task**: возвращает `contract.get_task_spec()` (только contract_id, work_units_required, difficulty).
  - **submit_work**: контракт берётся по contract_id из CONTRACTS; вызывается `contract.verify(..., nonce)`; при успехе — `contract.get_reward()`, создание reward_tx и work_receipt_tx, майнинг, синхронизация с пиром. Убраны лишние print, добавлены комментарии к строкам.

- **`client_worker/worker.py`**  
  - Задача теперь приходит как спецификация без `description`: используются **contract_id**, **work_units_required**, **difficulty**.
  - **perform_computation**: использует `task["difficulty"]` и `task["work_units_required"]`; при нахождении хеша с нужным префиксом сохраняется **solution_nonce**; возвращает `(work_units_done, result_data, solution_nonce)`.
  - **submit_work**: в payload добавлено поле **nonce** (solution_nonce) для строгой проверки контрактом на оркестраторе. Удалены лишние print, добавлены комментарии к строкам.

### Итог по контрактам

| Было | Стало |
|------|--------|
| Контракты — JSON (описание, work_units_required, reward) | Контракты — исполняемые классы (verify + get_reward) |
| Верификация «на доверии» (work_units_done >= требуемого) | Верификация: объём работы + при наличии nonce пересчёт хеша и сравнение с result_data |
| Задача для воркера: полный JSON с description | Задача: минимальная спецификация (contract_id, work_units_required, difficulty) |
| Воркер парсил difficulty из description | Воркер получает difficulty из get_task_spec() |
| Нет nonce в отчёте | Воркер отправляет nonce; контракт проверяет hash(client_id-contract_id-nonce) == result_data |

Изменения зафиксированы в Git (коммит с сообщением про исполняемые смарт-контракты).

---

## 6. Настоящий консенсус Proof-of-Work вместо Proof-of-Authority

### Запрос из чата
Добавить **настоящий консенсус** вместо Proof-of-Authority; оставить пояснение рядом с каждой строкой кода; зафиксировать изменения и чат в CHAT_AND_CHANGES.md.

### Что сделано

- **`orchestrator_node/blockchain.py`**
  - В начале файла добавлен комментарий: консенсус — **Proof-of-Work (PoW)**; блок принимается только если хеш удовлетворяет сложности; любой узел может майнить.
  - **Block**: комментарии к полям и к `mine_block` (подбор nonce до валидного хеша).
  - **Blockchain**: `pending_transactions` — общая очередь для всех узлов; `add_transaction` — «майнить будет любой узел (PoW), не один авторитет»; `mine_pending_transactions` — «любой узел вызывает при наличии pending tx», без лишних print; опциональная награда за блок только при переданном `mining_reward_address`.
  - **add_block_from_peer**: явная проверка PoW (хеш блока с нужным префиксом); после принятия блока **очистка `pending_transactions`**, чтобы не майнить те же tx повторно (консенсус: пир выиграл раунд). Рядом с логическими строками — поясняющие комментарии.

- **`orchestrator_node/app.py`**
  - **mining_loop()**: фоновый цикл — при наличии `pending_transactions` вызывается `mine_pending_transactions(mining_reward_address=None)`; найденный блок отправляется пиру в `/receive_block`. Комментарии у каждой строки (пауза, пустая очередь, рассылка блока, консенсус).
  - **submit_work**: после добавления reward_tx и work_receipt_tx в блокчейн — **распространение этих tx на пир** через `POST /add_pending_tx`; майнинг не вызывается здесь — блок создаётся в фоне в `mining_loop`. Комментарии к строкам.
  - **POST /add_pending_tx**: приём списка транзакций от пира и добавление их в `blockchain.pending_transactions`, чтобы оба узла майнили один и тот же pending (конкуренция за блок, консенсус PoW). Комментарии к строкам.
  - **receive_block**: комментарий — «консенсус PoW: первый валидный блок принимается, pending очищается».
  - В **if __name__ == "__main__"** запускается поток **mining_loop** (консенсус PoW: майнит любой узел).

### Итог по консенсусу

| Было (Proof-of-Authority) | Стало (Proof-of-Work) |
|---------------------------|------------------------|
| Только узел, принявший submit_work, майнит блок | Любой узел может майнить при наличии pending tx |
| Майнинг сразу в submit_work | Транзакции добавляются в pending и рассылаются пиру; майнинг в фоне (mining_loop) |
| Один «авторитет» создаёт блоки | Оба узла конкурируют за блок; первый найденный валидный блок рассылается и принимается |
| — | POST /add_pending_tx — синхронизация очереди tx между узлами |
| — | При приёме блока от пира pending очищается (не майним те же tx повторно) |

Консенсус: **Proof-of-Work** — валидность блока по хешу с заданной сложностью; «longest valid chain» при расхождении цепочек; пояснения к коду добавлены.
